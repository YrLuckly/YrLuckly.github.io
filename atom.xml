<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rafael</title>
  
  <subtitle>All the glory of life, to the end of the lonely repayment.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fireworksrain.com/"/>
  <updated>2018-11-25T09:08:59.029Z</updated>
  <id>http://fireworksrain.com/</id>
  
  <author>
    <name>Mr Zuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux下安装Django</title>
    <link href="http://fireworksrain.com/linux%E4%B8%8B%E5%AE%89%E8%A3%85Django/"/>
    <id>http://fireworksrain.com/linux下安装Django/</id>
    <published>2018-11-25T09:05:19.000Z</published>
    <updated>2018-11-25T09:08:59.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于安装python安装django"><a href="#基于安装python安装django" class="headerlink" title="基于安装python安装django"></a>基于安装python安装django</h1><h3 id="非常简答"><a href="#非常简答" class="headerlink" title="非常简答"></a>非常简答</h3><h3 id="前提是安装好Python"><a href="#前提是安装好Python" class="headerlink" title="前提是安装好Python"></a>前提是安装好Python</h3><p><code>pip3 install django==1.11.14</code></p><blockquote><p>接下来就是最基本的django的创建和运行<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">创建django项目</span><br><span class="line">django-admin startproject mysite</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改django settings.<span class="keyword">py</span>配置文件，不知道可以用<span class="keyword">find</span>查找</span><br><span class="line">ALLOWED_HOSTS = [<span class="string">'*'</span>]</span><br><span class="line">启动django</span><br><span class="line"></span><br><span class="line"><span class="keyword">python3</span> manage.<span class="keyword">py</span> runserver <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">9000</span></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于安装python安装django&quot;&gt;&lt;a href=&quot;#基于安装python安装django&quot; class=&quot;headerlink&quot; title=&quot;基于安装python安装django&quot;&gt;&lt;/a&gt;基于安装python安装django&lt;/h1&gt;&lt;h3 id=&quot;非
      
    
    </summary>
    
      <category term="Linux" scheme="http://fireworksrain.com/categories/Linux/"/>
    
    
      <category term="Django" scheme="http://fireworksrain.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用部署之MySQL(mariadb)</title>
    <link href="http://fireworksrain.com/Linux%E5%B8%B8%E7%94%A8%E9%83%A8%E7%BD%B2%E4%B9%8BMySQL-mariadb/"/>
    <id>http://fireworksrain.com/Linux常用部署之MySQL-mariadb/</id>
    <published>2018-11-23T00:42:12.000Z</published>
    <updated>2018-11-26T07:22:04.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mariadb的安装与其他设置"><a href="#mariadb的安装与其他设置" class="headerlink" title="mariadb的安装与其他设置"></a>mariadb的安装与其他设置</h2><p>@[toc]</p><h4 id="1-添加MariaDb-yum-仓库"><a href="#1-添加MariaDb-yum-仓库" class="headerlink" title="1.添加MariaDb yum 仓库"></a>1.添加MariaDb yum 仓库</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、首先在 RHEL/CentOS 和 Fedora 操作系统中添加 MariaDB 的 YUM 配置文件 MariaDB<span class="selector-class">.repo</span> 文件。</span><br><span class="line">#编辑创建mariadb.repo仓库文件</span><br><span class="line">vi /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span>/MariaDB.repo</span><br></pre></td></tr></table></figure><h4 id="1-1-添加repo仓库配置"><a href="#1-1-添加repo仓库配置" class="headerlink" title="1.1 添加repo仓库配置"></a>1.1 添加repo仓库配置</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mariadb]</span></span><br><span class="line"><span class="attr">name</span> = MariaDB</span><br><span class="line"><span class="attr">baseurl</span> = http://yum.mariadb.org/<span class="number">10.1</span>/centos7-amd64</span><br><span class="line"><span class="attr">gpgkey</span>=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="2-在CentOS7中安装MariaDB"><a href="#2-在CentOS7中安装MariaDB" class="headerlink" title="2 在CentOS7中安装MariaDB"></a>2 在CentOS7中安装MariaDB</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>、当 <span class="keyword">MariaDB </span>仓库地址添加好后，你可以通过下面的一行命令轻松安装 <span class="keyword">MariaDB。</span></span><br><span class="line"><span class="keyword">yum </span>install <span class="keyword">MariaDB-server </span><span class="keyword">MariaDB-client </span>-y</span><br></pre></td></tr></table></figure><h4 id="3-启动mariadb相关命令"><a href="#3-启动mariadb相关命令" class="headerlink" title="3.启动mariadb相关命令"></a>3.启动mariadb相关命令</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mariadb数据库的相关命令是：</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">systemctl </span>start <span class="keyword">mariadb </span> #启动<span class="keyword">MariaDB</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">systemctl </span>stop <span class="keyword">mariadb </span> #停止<span class="keyword">MariaDB</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">systemctl </span>restart <span class="keyword">mariadb </span> #重启<span class="keyword">MariaDB</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">systemctl </span>enable <span class="keyword">mariadb </span> #设置开机启动</span><br></pre></td></tr></table></figure><p>启动后正常使用mysql<br><code>systemctl start mariadb</code></p><h3 id="初始化mysql-必要操作！！"><a href="#初始化mysql-必要操作！！" class="headerlink" title="初始化mysql(必要操作！！)"></a>初始化mysql(必要操作！！)</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在确认 <span class="keyword">MariaDB </span>数据库软件程序安装完毕并成功启动后请不要立即使用。为了确保数据 库的安全性和正常运转，需要先对数据库程序进行初始化操作。这个初始化操作涉及下面 <span class="number">5</span> 个 步骤。</span><br><span class="line">➢ 设置 root 管理员在数据库中的密码值(注意，该密码并非 root 管理员在系统中的密 码，这里的密码值默认应该为空，可直接按回车键)。</span><br><span class="line">➢ 设置 root 管理员在数据库中的专有密码。</span><br><span class="line">➢ 随后删除匿名账户，并使用 root 管理员从远程登录数据库，以确保数据库上运行的业</span><br><span class="line">务的安全性。</span><br><span class="line">➢ 删除默认的测试数据库，取消测试数据库的一系列访问权限。</span><br><span class="line">➢ 刷新授权列表，让初始化的设定立即生效。</span><br></pre></td></tr></table></figure><p><strong>必须在确保mariadb服务器启动后，执行初始化命令</strong><br><code>mysql_secure_installation</code><br>操作如下图：<br><img src="https://img-blog.csdnimg.cn/20181126152150897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgwMjk4Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="mysql基础命令"><a href="#mysql基础命令" class="headerlink" title="mysql基础命令"></a>mysql基础命令</h3><p>mysql创建普通用户：</p><pre><code>#修改mysql密码MariaDB [(none)]&gt; set password = PASSWORD(&apos;redhat123&apos;);生产环境里不会死磕root用户，为了数据库的安全以及和其他用户协同管理数据库，就需要创建其他数据库账户，然后分配权限，满足工作需求。</code></pre><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; <span class="keyword">create</span> <span class="keyword">user</span> yuchao@<span class="string">'127.0.0.1'</span> identified <span class="keyword">by</span> <span class="string">'redhat123'</span>;</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; use mysql;</span><br><span class="line"></span><br><span class="line">MariaDB [mysql]&gt; <span class="keyword">select</span> host,<span class="keyword">user</span>,<span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'yuchao'</span>;</span><br><span class="line">切换普通用户yuchao，查看数据库信息，发现无法看到完整的数据库列表</span><br><span class="line"></span><br><span class="line">[root@master ~]# mysql -uyuchao -p -h 127.0.0.1</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show databases;</span><br></pre></td></tr></table></figure><h3 id="数据库权限设置"><a href="#数据库权限设置" class="headerlink" title="数据库权限设置"></a>数据库权限设置</h3><p><code>mysql使用grant命令对账户进行授权，grant命令常见格式如下</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限 <span class="keyword">on</span> 数据库.表名 <span class="keyword">to</span> 账户@主机名            对特定数据库中的特定表授权</span><br><span class="line"><span class="keyword">grant</span> 权限 <span class="keyword">on</span> 数据库.* <span class="keyword">to</span> 账户@主机名            　　对特定数据库中的所有表给与授权</span><br><span class="line"><span class="keyword">grant</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,权限<span class="number">3</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> 账户@主机名   　　 对所有库中的所有表给与多个授权</span><br><span class="line"><span class="keyword">grant</span> all <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> 账户@主机名   　　 对所有库和所有表授权所有权限</span><br></pre></td></tr></table></figure></p><p>退出数据库，使用root登录，开始权限设置<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@master ~]</span># <span class="selector-tag">mysql</span> <span class="selector-tag">-uroot</span> <span class="selector-tag">-p</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">MariaDB</span> <span class="selector-attr">[(none)]</span>&gt; <span class="selector-tag">use</span> <span class="selector-tag">mysql</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">MariaDB</span> <span class="selector-attr">[(none)]</span>&gt; <span class="selector-tag">grant</span> <span class="selector-tag">all</span> <span class="selector-tag">privileges</span> <span class="selector-tag">on</span> *.* <span class="selector-tag">to</span> <span class="selector-tag">yuchao</span>@<span class="keyword">127</span>.<span class="keyword">0</span>.<span class="keyword">0</span>.<span class="keyword">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">MariaDB</span> <span class="selector-attr">[mysql]</span>&gt; <span class="selector-tag">show</span> <span class="selector-tag">grants</span> <span class="selector-tag">for</span> <span class="selector-tag">yuchao</span>@<span class="keyword">127</span>.<span class="keyword">0</span>.<span class="keyword">0</span>.<span class="keyword">1</span>;</span><br></pre></td></tr></table></figure></p><p>移除权限<br><code>MariaDB [(none)]&gt; revoke all privileges on *.* from yuchao@127.0.0.1;</code></p><h3 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h3><h4 id="1-中文编码设置，编辑mysql配置文件-etc-my-cnf-填写一下内容"><a href="#1-中文编码设置，编辑mysql配置文件-etc-my-cnf-填写一下内容" class="headerlink" title="1.中文编码设置，编辑mysql配置文件/etc/my.cnf,填写一下内容"></a>1.中文编码设置，编辑mysql配置文件/etc/my.cnf,填写一下内容</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-<span class="keyword">set</span>-<span class="keyword">server</span>=utf8</span><br><span class="line"><span class="keyword">collation</span>-<span class="keyword">server</span>=utf8_general_ci</span><br><span class="line"><span class="keyword">log</span>-<span class="keyword">error</span>=/<span class="keyword">var</span>/<span class="keyword">log</span>/mysqld.log</span><br><span class="line">[<span class="keyword">client</span>]</span><br><span class="line"><span class="keyword">default</span>-<span class="built_in">character</span>-<span class="keyword">set</span>=utf8</span><br><span class="line">[mysql]</span><br><span class="line"><span class="keyword">default</span>-<span class="built_in">character</span>-<span class="keyword">set</span>=utf8</span><br></pre></td></tr></table></figure><h4 id="2-授权设置"><a href="#2-授权设置" class="headerlink" title="2.授权设置"></a>2.授权设置</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">远程连接设置哦设置所有库，所有表的所有权限，赋值权限给所有ip地址的root用户mysql &gt; grant all privileges <span class="keyword">on</span> *.* <span class="keyword">to</span> root@<span class="string">'%'</span> identified <span class="keyword">by</span> <span class="string">'password'</span>;#创建用户mysql &gt; <span class="keyword">create</span> user <span class="string">'username'</span>@<span class="string">'%'</span> identified <span class="keyword">by</span> <span class="string">'password'</span>;#刷新权限flush privileges;</span><br></pre></td></tr></table></figure><h3 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h3><ul><li>mysqldump命令用于备份数据库数据<br><code>[root@master ~]# mysqldump -u root -p --all-databases &gt; /tmp/db.dump</code></li><li><p>进入mariadb数据库，删除一个db</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="keyword">master</span> <span class="title">~]# mysql</span> -uroot -p</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; drop database s11;</span><br></pre></td></tr></table></figure></li><li><p>进行数据恢复，把刚才重定向备份的数据库文件导入到mysql中<br><code>[root@master ~]# mysql -uroot -p &lt; /tmp/db.dump</code></p><h3 id="mysql远程登陆授权配置"><a href="#mysql远程登陆授权配置" class="headerlink" title="mysql远程登陆授权配置"></a>mysql远程登陆授权配置</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">注意！关闭防火墙。、。。。。这样就不会再出莫名其妙的bug了。。。</span><br><span class="line">iptables -F  <span class="comment">#清空防火墙规则</span></span><br><span class="line"><span class="comment">#关闭防火墙 </span></span><br><span class="line">systemctl <span class="keyword">stop</span> firewalld</span><br><span class="line"><span class="comment">#永久关闭防火墙开机自启</span></span><br><span class="line">systemctl <span class="keyword">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>新建一个用于远程登录的账户</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'username'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'password'</span>;</span><br><span class="line">2.给与账户远程登录的权限，授权</span><br><span class="line"><span class="keyword">grant</span> all <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'username'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'password'</span>;</span><br><span class="line">3.刷新权限表，防止不生效</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line">4.此时可以在windows登录你的linux数据库拉！！！！</span><br></pre></td></tr></table></figure></li></ul><h3 id="mysql主从同步配置（重点）"><a href="#mysql主从同步配置（重点）" class="headerlink" title="mysql主从同步配置（重点）"></a>mysql主从同步配置（重点）</h3><h4 id="1-主库设置配置："><a href="#1-主库设置配置：" class="headerlink" title="1.主库设置配置："></a>1.主库设置配置：</h4><ol><li><p>修改配置文件，开启主从同步的功能<br> 1.修改配置文件</p><pre><code>`vim /etc/my.cnf`</code></pre><p> 2.修改内容</p> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">log-bin</span>=mysql-bin</span><br></pre></td></tr></table></figure><p> 3.重启mariadb<br> <code>systemctl start mariadb</code><br> 4.重启后，mysql主库已经开启同步功能，创建了mysql-bin日志文件</p></li><li><p>创建用于主从同步的账号<br><code>create user &#39;username&#39;@&#39;%&#39; identified by &#39;password&#39;;</code></p></li><li>给与账号slave的权限<br>grant replication slave on <em>.</em> to ‘username‘@’%’;</li><li>检查一下主库创建的账号信息<br>select user,host from mysql.user;</li><li>检查授权账号的权限信息<br>show grants for username@’%’;</li><li>实现主库的锁表，防止数据写入<br>flush table with read lock;</li><li>此时可以检查主库的日志状态，已经锁表了，防止日志位置发生变化<br>show master status;</li><li>开始数据备份，导出主库的已经存在的数据，然后用于从库写入<br>mysqldump -uroot -p  –all-databases &gt; /data/my_all.dump</li><li>将主库的数据备份文件，scp到从库机器上，然后从库mysql导入数据<br>scp /tmp/all.dump <a href="mailto:root@10.0.0.11" target="_blank" rel="noopener">root@10.0.0.11</a>:/opt/</li></ol><h4 id="2-从库的设置："><a href="#2-从库的设置：" class="headerlink" title="2.从库的设置："></a>2.从库的设置：</h4><pre><code>1. 在从库中导入主库的最新数据，以便于素具一致性        1.登录slave数据库        2.删除slave当前机器所有的database，清空database数据，为了保证从库干净        3.登录数据库，导入数据            `source /opt/all.dump`2. 修改配置文件，添加用于同步的配置，</code></pre><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/<span class="keyword">my</span>.cnf   写入配置</span><br><span class="line">server-<span class="built_in">id</span>=<span class="number">5</span></span><br></pre></td></tr></table></figure><pre><code>3. 重启mariadb 从库</code></pre><p><code>systemctl restart mariadb</code></p><pre><code>4. 检查从库的各项参数</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'log_bin'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'server_id'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>5.通过此命令，将slave库同于master库</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> <span class="attribute">master_host</span>=<span class="string">'10.0.0.10'</span>,</span><br><span class="line"><span class="attribute">master_user</span>=<span class="string">'bhf'</span>,</span><br><span class="line"><span class="attribute">master_password</span>=<span class="string">'bhfdsb'</span>,</span><br><span class="line"><span class="attribute">master_log_file</span>=<span class="string">'mysql-bin.000001'</span>,</span><br><span class="line"><span class="attribute">master_log_pos</span>=1485;</span><br></pre></td></tr></table></figure><blockquote><p>6.开启主从同步的开关<br>    <code>start slave;</code></p></blockquote><blockquote><p>7.检查复制的状态<br>        <code>show slave status\G</code></p></blockquote><blockquote><p>8.检查从库通过不得两条参数，均为yes确认同步成功</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Slave_IO_Running:</span> <span class="literal">Yes</span></span><br><span class="line"><span class="attr">Slave_SQL_Running:</span> <span class="literal">Yes</span></span><br></pre></td></tr></table></figure><blockquote><p>9.此时已经确认主从同步配置ok，前往主库解锁数据库，然后数据写入查看结果</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master上：</span><br><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;  解锁数据库</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mariadb的安装与其他设置&quot;&gt;&lt;a href=&quot;#mariadb的安装与其他设置&quot; class=&quot;headerlink&quot; title=&quot;mariadb的安装与其他设置&quot;&gt;&lt;/a&gt;mariadb的安装与其他设置&lt;/h2&gt;&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h4 id=
      
    
    </summary>
    
      <category term="Linux" scheme="http://fireworksrain.com/categories/Linux/"/>
    
    
      <category term="MySQL" scheme="http://fireworksrain.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Nginx入门</title>
    <link href="http://fireworksrain.com/Nginx%E5%85%A5%E9%97%A8/"/>
    <id>http://fireworksrain.com/Nginx入门/</id>
    <published>2018-11-22T09:31:32.000Z</published>
    <updated>2018-11-26T12:54:57.187Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="Web服务访问流程："><a href="#Web服务访问流程：" class="headerlink" title="Web服务访问流程："></a>Web服务访问流程：</h3><blockquote><p>dns解析流程：<br>1.你要输入域名  pythonav.cn<br>    2.你的机器首先在/etc/hosts文件中查找解析记录<br>    3.会去本地dns缓存中查找记录，LDNS<br>    4.就去/etc/resolv.conf去找到指定的公网dns服务器<br>    5.假设你dns服务器是119.29.29.29<br>        通过119.29.29.29找到对应的记录<br>        pythonav.cn    123.206.16.61<br>    6.找到记录后，机器会将此记录，缓存到LDNS中，用于下次加速解析<br>    7.浏览器访问对应的ip ，123.206.16.61，发起http请求</p></blockquote><h3 id="nginx的介绍"><a href="#nginx的介绍" class="headerlink" title="nginx的介绍"></a>nginx的介绍</h3><blockquote><p>支持高并发，能支持几万并发连接资源消耗少，在3万并发连接下开启10个nginx线程消耗的内存不到200M可以做http反向代理和负载均衡支持异步网络i/o事件模型epoll</p></blockquote><h3 id="安装、启动nginx"><a href="#安装、启动nginx" class="headerlink" title="安装、启动nginx"></a>安装、启动nginx</h3><ol><li>安装前准备<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install </span>gcc patch libffi-devel python-devel  zlib-devel <span class="keyword">bzip2-devel </span>openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel openssl openssl-devel -y</span><br></pre></td></tr></table></figure></li></ol><p>2.下载源码包<br><code>wget -c https://nginx.org/download/nginx-1.12.0.tar.gz</code><br>3.解压源码<br><code>tar -zxvf nginx-1.12.0.tar.gz</code><br>4.配置，编译安装<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> nginx1-<span class="number">12</span></span><br><span class="line"></span><br><span class="line">./configure --prefix=/<span class="keyword">opt</span>/nginx1-<span class="number">12</span>/</span><br><span class="line"></span><br><span class="line"><span class="keyword">make</span> &amp;&amp; <span class="keyword">make</span> install</span><br></pre></td></tr></table></figure></p><p>5.启动nginx，进入sbin目录，找到启动命令<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> sbin</span><br><span class="line"><span class="string">./nginx</span> <span class="comment">#启动</span></span><br><span class="line"><span class="string">./nginx</span> -s stop <span class="comment">#关闭</span></span><br><span class="line"><span class="string">./nginx</span> -s <span class="keyword">reload</span> <span class="comment">#重新加载</span></span><br></pre></td></tr></table></figure></p><p>6.检查<br><code>netstat -tunlp |grep 80</code></p><h3 id="Nginx的目录结构"><a href="#Nginx的目录结构" class="headerlink" title="Nginx的目录结构"></a>Nginx的目录结构</h3><blockquote><p>在nginx1-12中输入ls</p></blockquote><ol><li>conf 存放nginx所有配置文件的目录，主要会用到nginx.conf</li><li>html 存放nginx默认站点的目录，如index.html、error.html等</li><li>logs 存放nginx默认日志的目录，如error.log， access.log</li><li>sbin 存放nginx朱命令的目录，sbin/nginx (在这目录下启动)<h3 id="Nginx虚拟主机实战"><a href="#Nginx虚拟主机实战" class="headerlink" title="Nginx虚拟主机实战"></a>Nginx虚拟主机实战</h3><blockquote><p>虚拟主机的类型</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">基于域名的虚拟主机</span><br><span class="line">通过不同的域名区分不同的虚拟主机，是企业应用最广的虚拟主机</span><br><span class="line"></span><br><span class="line">基于端口的虚拟主机</span><br><span class="line">通过不同的端口来区分不同的虚拟主机，一般用作企业内部网站，不对外直接提供服务的后台，例如www.pythonav.cn:<span class="number">9000</span></span><br><span class="line"></span><br><span class="line">基于<span class="built_in">IP</span>的虚拟主机</span><br><span class="line">通过不同的<span class="built_in">IP</span>区分不同的虚拟主机，此类比较少见，一般业务需要多<span class="built_in">IP</span>的常见都会在负载均衡中绑定VIP</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p>基于域名的虚拟主机实战nginx可以自动识别用户请求的域名，根据不同的域名请求服务器传输不同的内容，只需要保证服务器上有一个可用的ip地址，配置好dns解析服务。</p></blockquote><h4 id="基于一个ip地址的一个域名访问"><a href="#基于一个ip地址的一个域名访问" class="headerlink" title="基于一个ip地址的一个域名访问"></a>基于一个ip地址的一个域名访问</h4><blockquote><p>修改nginx.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@oldboy_python ~ 14:33:16]#egrep -v &apos;#|^$&apos; /opt/nginx1-12/conf/nginx.conf</span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.diyi.com;</span><br><span class="line">        location /&#123;</span><br><span class="line">            root   html/pyyuc;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>创建diyi.com的站点目录和文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@oldboy_python /opt/nginx1-12/html 14:36:08]#mkdir diyi</span><br><span class="line">[root@oldboy_python /opt/nginx1-12/html 14:36:18]#echo &quot;&lt;meta charset=utf8&gt;我是diyi站点&quot; &gt; diyi/index.html</span><br><span class="line">[root@oldboy_python /opt/nginx1-12/html 14:37:21]#cat diyi/index.html</span><br><span class="line">&lt;meta charset=utf8&gt;我是diyi站点</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>完成后重启nginx,就可以访问了<br><code>./nginx -s reload</code></p></blockquote><h4 id="基于同一ip访问多个域名"><a href="#基于同一ip访问多个域名" class="headerlink" title="基于同一ip访问多个域名"></a>基于同一ip访问多个域名</h4><blockquote><p><strong>新增一个新的server{}</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">egrep -v &apos;#|^$&apos; /opt/nginx1-12/conf/nginx.conf</span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.pyyuc.cn;</span><br><span class="line">        location /&#123;</span><br><span class="line">            root   html/pyyuc;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.pythonav.cn;</span><br><span class="line">        location /&#123;</span><br><span class="line">            root   html/pythonav;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>创建第二模拟主机站点的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy_python /opt/nginx1-12 14:47:21]#mkdir -p /opt/nginx1-12/html/pythonav</span><br><span class="line">[root@oldboy_python /opt/nginx1-12 14:49:33]#echo &quot;&lt;meta charset=utf8&gt;我是pythonav，未成年禁止入内&quot;&gt; /opt/nginx1-12/html/pythonav/index.html</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>重启，输入域名</p></blockquote><h3 id="nginx访问日志（access-log）"><a href="#nginx访问日志（access-log）" class="headerlink" title="nginx访问日志（access_log）"></a>nginx访问日志（access_log）</h3><blockquote></blockquote><p>日志功能对每个用户访问网站的日志信息记录到指定的日志文件里，开发运维人员可以分析用户的浏览器行为，此功能由ngx_http_log_module模块负责，<a href="http://nginx.org/en/docs/http/ngx_http_log_module.html" target="_blank" rel="noopener">官方文档</a><br>控制日志的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format    记录日志的格式，可定义多种格式</span><br><span class="line">accsss_log    指定日志文件的路径以及格式　　log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">　　&apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">　　&apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br></pre></td></tr></table></figure></p><p>对应参数解析<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$remote</span>_addr    记录客户端ip</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$remote</span>_user    远程用户，没有就是 “-”</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$time</span>_local 　　 对应[14/Aug/2018:18:46:52 +0800]</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$request</span>　　　 　对应请求信息"GET /favicon.ico HTTP/1.1"</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$status</span>　　　  　状态码</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$body</span>_bytes_sent　　571字节 请求体的大小</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$http</span>_referer　　对应“-”　　由于是直接输入浏览器就是 -</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$http</span>_user_agent　　客户端身份信息</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$http</span>_x_forwarded_for　　记录客户端的来源真实ip 97.64.34.118</span></span><br></pre></td></tr></table></figure></p><blockquote><p>nginx.conf默认配置<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> access_log  logs/access.log  main<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">log_format是日志关键字参数，不能变</span><br><span class="line">main是日志格式指定的标签，记录日志时通过main标签选择指定的格式。</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="限制网站来源ip访问"><a href="#限制网站来源ip访问" class="headerlink" title="限制网站来源ip访问"></a>限制网站来源ip访问</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">限制ip或ip段访问</span><br><span class="line">location / &#123;</span><br><span class="line">deny <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>;</span><br><span class="line">deny <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span>;</span><br><span class="line">allow <span class="number">10.1</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">16</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx错误页面优化"><a href="#Nginx错误页面优化" class="headerlink" title="Nginx错误页面优化"></a>Nginx错误页面优化</h3><blockquote><p>自定义一个错误404页面<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.pythonav.cn;</span><br><span class="line">        root html/pythonav;</span><br><span class="line">        location /&#123;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;　　　　　　#在pythonav路径下的40x.html错误页面</span><br><span class="line">        error_page 400 403 404 405 /40x.html;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h3><blockquote><p>1.正向代理的概念<br>    正向代理，实际应用在，vpn代理ip<br>    那么用户在家的时候，通过一个代理ip，连接上公司的内网环境<br>    这个ip就是一个正向代理ip</p></blockquote><blockquote><p>2.反向代理<br>    1.用户发起请求  pythonav.cn/login/ ，访问到nginx服务器，告诉nginx，我要登录</p><pre><code>2. nginx 作为一个中间代理，他不做处理，他把这请求，直接扔给后面的应用服务器,django 3.django接收到login请求，处理请求，返回请求再给nginx4.nginx返回处理完毕的页面，数据，返回给用户/浏览器5.客户/浏览器得到一个处理完毕的结果</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;Web服务访问流程：&quot;&gt;&lt;a href=&quot;#Web服务访问流程：&quot; class=&quot;headerlink&quot; title=&quot;Web服务访问流程：&quot;&gt;&lt;/a&gt;Web服务访问流程：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;dns解析流程：&lt;br&gt;1.你要输入域名
      
    
    </summary>
    
      <category term="Linux" scheme="http://fireworksrain.com/categories/Linux/"/>
    
    
      <category term="nginx" scheme="http://fireworksrain.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>linux下的python</title>
    <link href="http://fireworksrain.com/linux%E4%B8%8B%E7%9A%84python/"/>
    <id>http://fireworksrain.com/linux下的python/</id>
    <published>2018-11-21T17:51:33.000Z</published>
    <updated>2018-11-23T00:55:10.321Z</updated>
    
    <content type="html"><![CDATA[<p>将进酒</p><p>唐代：李白</p><p>君不见，黄河之水天上来，奔流到海不复回。<br>君不见，高堂明镜悲白发，朝如青丝暮成雪。<br>人生得意须尽欢，莫使金樽空对月。<br>天生我材必有用，千金散尽还复来。<br>烹羊宰牛且为乐，会须一饮三百杯。<br>岑夫子，丹丘生，将进酒，杯莫停。<br>与君歌一曲，请君为我倾耳听。<br>钟鼓馔玉不足贵，但愿长醉不复醒。<br>古来圣贤皆寂寞，惟有饮者留其名。<br>陈王昔时宴平乐，斗酒十千恣欢谑。<br>主人何为言少钱，径须沽取对君酌。<br>五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。</p><h1 id="在Linux中安装Python的操作步骤"><a href="#在Linux中安装Python的操作步骤" class="headerlink" title="在Linux中安装Python的操作步骤"></a>在Linux中安装Python的操作步骤</h1><h3 id="1-安装Python前的环境准备，非常非常重要！！！！"><a href="#1-安装Python前的环境准备，非常非常重要！！！！" class="headerlink" title="1.安装Python前的环境准备，非常非常重要！！！！"></a>1.安装Python前的环境准备，非常非常重要！！！！</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install </span>gcc patch libffi-devel python-devel  zlib-devel <span class="keyword">bzip2-devel </span>openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel -y</span><br></pre></td></tr></table></figure><h3 id="2-下载安装源码包"><a href="#2-下载安装源码包" class="headerlink" title="2.下载安装源码包"></a>2.下载安装源码包</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/<span class="number">3.4</span><span class="meta">.7</span>/Python-<span class="number">3.4</span><span class="meta">.7</span>.tar.xzxz -d Python-<span class="number">3.4</span><span class="meta">.7</span>.tar.xztar -xf Python-<span class="number">3.4</span><span class="meta">.7</span>.tar</span><br></pre></td></tr></table></figure><p>在opt的文件夹下执行此代码<br><code>[root@localhost opt]# wget https://www.python.org/ftp/python/3.4.7/Python-3.4.7.tar.xzxz -d Python-3.4.7.tar.xztar -xf Python-3.4.7.tar</code></p><h3 id="3解压python源代码"><a href="#3解压python源代码" class="headerlink" title="3解压python源代码"></a>3解压python源代码</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">xz</span> <span class="selector-tag">-d</span> <span class="selector-tag">Python-3</span><span class="selector-class">.4</span><span class="selector-class">.7</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-xf</span> <span class="selector-tag">Python-3</span><span class="selector-class">.4</span><span class="selector-class">.7</span><span class="selector-class">.tar</span></span><br></pre></td></tr></table></figure><p>在opt的文件夹中操作<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost opt]</span># <span class="selector-tag">xz</span> <span class="selector-tag">-d</span> <span class="selector-tag">Python-3</span><span class="selector-class">.4</span><span class="selector-class">.7</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-attr">[root@localhost opt]</span># <span class="selector-tag">tar</span> <span class="selector-tag">-xf</span> <span class="selector-tag">Python-3</span><span class="selector-class">.4</span><span class="selector-class">.7</span><span class="selector-class">.tar</span></span><br></pre></td></tr></table></figure></p><h3 id="4-切换进入python源码目录"><a href="#4-切换进入python源码目录" class="headerlink" title="4.切换进入python源码目录"></a>4.切换进入python源码目录</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/opt/Python-3.4.7</span></span><br></pre></td></tr></table></figure><h3 id="5-开始编译安装，释放编译文件"><a href="#5-开始编译安装，释放编译文件" class="headerlink" title="5.开始编译安装，释放编译文件"></a>5.开始编译安装，释放编译文件</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/configure --prefix=/</span>opt<span class="regexp">/python347/</span>    <span class="comment">#此时还不会生成这个文件夹！</span></span><br></pre></td></tr></table></figure><p>在opt文件夹下的Python-3.4.7运行<br><code>[root@localhost Python-3.4.7]# ./configure --prefix=/opt/python347/</code></p><h3 id="6-开始编译，编译安装-两种"><a href="#6-开始编译，编译安装-两种" class="headerlink" title="6.开始编译，编译安装(两种)"></a>6.开始编译，编译安装(两种)</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line"> <span class="built_in">make</span> </span><br><span class="line"><span class="built_in">make</span> install     <span class="meta">#直到这两步走完，才会生成。创建 /opt/python347/</span></span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="built_in">make</span> &amp;&amp; <span class="built_in">make</span> install</span><br></pre></td></tr></table></figure><p>继续在opt文件夹下的Python-3.4.7运行<br><code>[root@localhost Python-3.4.7]# make &amp;&amp; make install</code></p><blockquote><p>到这就可以运行python了<br>到opt文件夹下的python347文件夹下的bin目录中输入./python3<br>这是就会出现非常熟悉有感觉的界面<br>接下来就为了创建快捷方式</p></blockquote><h3 id="8-配置软连接，快捷启动python3和pip3"><a href="#8-配置软连接，快捷启动python3和pip3" class="headerlink" title="8.配置软连接，快捷启动python3和pip3"></a>8.配置软连接，快捷启动python3和pip3</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="meta-keyword">/opt/</span>python347<span class="meta-keyword">/bin/</span>python3    <span class="meta-keyword">/usr/</span>bin/python3</span><br><span class="line">ln -s <span class="meta-keyword">/opt/</span>python347<span class="meta-keyword">/bin/</span>pip3  <span class="meta-keyword">/usr/</span>bin/pip3</span><br></pre></td></tr></table></figure><blockquote><p>在根目录下执行软连接：ln -s /opt/python347/bin/python3    /usr/bin/python3<br>在根目录继续创建软链接：ln -s /opt/python347/bin/pip3  /usr/bin/pip3</p></blockquote><h3 id="9-配置系统环境变量，配置PATH，加入python3的目录-目的跟上一步相同-配置环境变量须谨慎"><a href="#9-配置系统环境变量，配置PATH，加入python3的目录-目的跟上一步相同-配置环境变量须谨慎" class="headerlink" title="9. 配置系统环境变量，配置PATH，加入python3的目录(目的跟上一步相同)配置环境变量须谨慎"></a>9. 配置系统环境变量，配置PATH，加入python3的目录(目的跟上一步相同)配置环境变量须谨慎</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.最好用这一步</span><br><span class="line">PATH=<span class="regexp">/opt/python</span>347/bin/<span class="symbol">:/usr/local/sbin</span><span class="symbol">:/usr/local/bin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/root/bin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.尽量不用</span><br><span class="line">PATH=<span class="variable">$PATH</span><span class="symbol">:/opt/python347/bin/</span></span><br><span class="line">将上面的写入到个人配置文件中，永久生效</span><br><span class="line">vim /etc/profile  <span class="comment">#编辑个人配置文件，写入PATH</span></span><br><span class="line">PATH=<span class="variable">$PATH</span><span class="symbol">:/opt/python347/bin/</span></span><br><span class="line">source /etc/profile  <span class="comment">#读取一下配置文件，生效配置</span></span><br></pre></td></tr></table></figure><h3 id="运行时遇到问题"><a href="#运行时遇到问题" class="headerlink" title="运行时遇到问题"></a>运行时遇到问题</h3><blockquote><p>网页访问不到 ：ptables -F  </p><ul><li>setenforce 0</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将进酒&lt;/p&gt;
&lt;p&gt;唐代：李白&lt;/p&gt;
&lt;p&gt;君不见，黄河之水天上来，奔流到海不复回。&lt;br&gt;君不见，高堂明镜悲白发，朝如青丝暮成雪。&lt;br&gt;人生得意须尽欢，莫使金樽空对月。&lt;br&gt;天生我材必有用，千金散尽还复来。&lt;br&gt;烹羊宰牛且为乐，会须一饮三百杯。&lt;br&gt;岑夫子，丹
      
    
    </summary>
    
      <category term="Linux" scheme="http://fireworksrain.com/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://fireworksrain.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python语言的介绍</title>
    <link href="http://fireworksrain.com/Python%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://fireworksrain.com/Python语言的介绍/</id>
    <published>2018-08-28T08:10:30.000Z</published>
    <updated>2019-08-28T09:33:32.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-编程语言的分类"><a href="#1-编程语言的分类" class="headerlink" title="1.编程语言的分类"></a>1.编程语言的分类</h3><p>编程语言主要从以下几个角度进行分类，编译型和解释型、静态语言和动态语言、强类型定义语言和弱类型定义语言。</p><h4 id="1-1-编译型与解释型"><a href="#1-1-编译型与解释型" class="headerlink" title="1.1 编译型与解释型"></a>1.1 编译型与解释型</h4><p>编译器是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快; </p><p>而解释器则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的. </p><p>这是因为计算机不能直接认识并执行我们写的语句,它只能认识机器语言(是二进制的形式)</p><p>编译型<br>优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。<br>缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</p><p>解释型<br>优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。</p><p>缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。</p><h3 id="1-2动态语言和静态语言"><a href="#1-2动态语言和静态语言" class="headerlink" title="1.2动态语言和静态语言"></a>1.2动态语言和静态语言</h3><p>通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。</p><p>（1）动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。</p><p>（2）静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。</p><h3 id="1-3强类型定义语言和弱类型定义语言"><a href="#1-3强类型定义语言和弱类型定义语言" class="headerlink" title="1.3强类型定义语言和弱类型定义语言"></a>1.3强类型定义语言和弱类型定义语言</h3><p>（1）强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。</p><p>（2）弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。</p><p>强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的！<br>例如：Python是动态语言，是强类型定义语言（类型安全的语言）; VBScript是动态语言，是弱类型定义语言（类型不安全的语言）; JAVA是静态语言，是强类型定义语言（类型安全的语言）。</p><p>通过上面这些介绍，我们可以得出，python是一门动态解释性的强类型定义语言。</p><h3 id="2-Python的种类"><a href="#2-Python的种类" class="headerlink" title="2.Python的种类"></a>2.Python的种类</h3><h4 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h4><p>当我们从Python官方网站下载并安装好Python 3.6后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。</p><p>CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。</p><h4 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h4><p>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。</p><p>CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。</p><h4 id="PyPy"><a href="#PyPy" class="headerlink" title="PyPy"></a>PyPy</h4><p>PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。</p><p>绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。</p><h4 id="Jython"><a href="#Jython" class="headerlink" title="Jython"></a>Jython</h4><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p><h4 id="IronPython"><a href="#IronPython" class="headerlink" title="IronPython"></a>IronPython</h4><p>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p><p>小结：</p><p>　　Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</p><h3 id="3-Python环境"><a href="#3-Python环境" class="headerlink" title="3.Python环境"></a>3.Python环境</h3><p>windows下安装：</p><pre><code>1. 下载安装包：  https://www.python.org/downloads/2. 安装：    默认安装路径：C:\python273. 配置环境变量：    【右键计算机】--》【属性】--》【高级系统设置】--》【高级】--》【环境变量】--》【在第二个内容框中找到 变量名为Path 的一行，双击】 --&gt; 【Python安装目录追加到变值值中，用 ； 分割】    如：原来的值;C:\python27，切记前面有分号4.注3.5版本可自动添加环境变量</code></pre><p>linux：</p><pre><code>无需安装，原装Python环境ps：如果自带2.6，请更新至2.7</code></pre><p><img src="https://i.imgur.com/JNifuzA.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-编程语言的分类&quot;&gt;&lt;a href=&quot;#1-编程语言的分类&quot; class=&quot;headerlink&quot; title=&quot;1.编程语言的分类&quot;&gt;&lt;/a&gt;1.编程语言的分类&lt;/h3&gt;&lt;p&gt;编程语言主要从以下几个角度进行分类，编译型和解释型、静态语言和动态语言、强类型定义语
      
    
    </summary>
    
      <category term="Python" scheme="http://fireworksrain.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Flask的模版语言Jinja2</title>
    <link href="http://fireworksrain.com/Flask%E7%9A%84%E6%A8%A1%E7%89%88%E8%AF%AD%E8%A8%80Jinja2/"/>
    <id>http://fireworksrain.com/Flask的模版语言Jinja2/</id>
    <published>2017-11-28T08:30:03.000Z</published>
    <updated>2018-11-27T10:49:37.005Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Python" scheme="http://fireworksrain.com/categories/Python/"/>
    
    
      <category term="Flask框架" scheme="http://fireworksrain.com/tags/Flask%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Flask的三剑客</title>
    <link href="http://fireworksrain.com/Flask%E7%9A%84%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <id>http://fireworksrain.com/Flask的三剑客/</id>
    <published>2017-11-27T09:49:04.000Z</published>
    <updated>2018-11-27T10:01:21.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三剑客"><a href="#三剑客" class="headerlink" title="三剑客"></a>三剑客</h3><p>Flask框架的三剑客跟Django的是有点区别的：</p><blockquote><p>HTTPResponse<br>Redirect<br>render_template</p></blockquote><h4 id="1-HTTPResponse"><a href="#1-HTTPResponse" class="headerlink" title="1.HTTPResponse"></a>1.HTTPResponse</h4><p>在Flask 中的HttpResponse 在我们看来其实就是直接返回字符串</p><pre><code>from flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def index():  # 视图函数    return &quot;Hello World&quot;   #返回一个字符串，类似于HttpResponseapp.run()</code></pre><h4 id="2-Redirect"><a href="#2-Redirect" class="headerlink" title="2.Redirect"></a>2.Redirect</h4><p>每当访问”/login”这个地址的时候,视图函数redi会触发redirect(“/“) 跳转到url地址:  “/“ 并会触发”/“对应的视图函数index()</p><pre><code>from flask import Flask,redirect  # 导入模块app = Flask(__name__)@app.route(&quot;/login&quot;)def redi():    return redirect(&quot;/&quot;) #redirect跳转至&apos;/&apos;app.run()</code></pre><h4 id="3-render-template"><a href="#3-render-template" class="headerlink" title="3.render_template"></a>3.render_template</h4><p>HTML模板渲染是每个Web框架中都必须有的,至于render_template的具体用法,</p><p>注意: 如果要使用 render_template 返回渲染的模板,请在项目的主目录中加入一个目录 templates,否则可能会有一个Jinja2的异常哦</p><pre><code>from flask import Flask,render_templateapp = Flask(__name__)@app.route(&quot;/login&quot;)def login():    return render_template(&quot;login.html&quot;)app.run()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;三剑客&quot;&gt;&lt;a href=&quot;#三剑客&quot; class=&quot;headerlink&quot; title=&quot;三剑客&quot;&gt;&lt;/a&gt;三剑客&lt;/h3&gt;&lt;p&gt;Flask框架的三剑客跟Django的是有点区别的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTPResponse&lt;br&gt;Red
      
    
    </summary>
    
      <category term="Python" scheme="http://fireworksrain.com/categories/Python/"/>
    
    
      <category term="Flask框架" scheme="http://fireworksrain.com/tags/Flask%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Flask的请求机制(request)</title>
    <link href="http://fireworksrain.com/Flask%E7%9A%84%E8%AF%B7%E6%B1%82%E6%9C%BA%E5%88%B6-request/"/>
    <id>http://fireworksrain.com/Flask的请求机制-request/</id>
    <published>2017-11-27T08:38:04.000Z</published>
    <updated>2018-11-27T09:46:26.915Z</updated>
    
    <content type="html"><![CDATA[<p>每个框架斗鱼处理请求的机制(request)，但每个框架的处理方式和机制是不同的</p><h3 id="认识request包含的内容"><a href="#认识request包含的内容" class="headerlink" title="认识request包含的内容"></a>认识request包含的内容</h3><h4 id="基于HTML-Flask写一段前后端交互"><a href="#基于HTML-Flask写一段前后端交互" class="headerlink" title="基于HTML + Flask写一段前后端交互"></a>基于HTML + Flask写一段前后端交互</h4><p>标准的form表单，点击登录就可以提交一个POST请求过去</p><pre><code>&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;    &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt;    &lt;p&gt;密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;/p&gt;    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt;</code></pre><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>首先要从flask包中导入request模块</p><pre><code>from flask import request@app.route(&quot;/login&quot;, methods=[&quot;POST&quot;])def req():    print(request.method) # POST看来可以使用这种方式来验证请求方式了    print(request.form) # ImmutableMultiDict([(&apos;user&apos;, &apos;Oldboy&apos;), (&apos;pwd, &apos;DragonFire&apos;)])# ImmutableMultiDict它看起来像是的Dict就用Dict的方法取值试一下吧print(request.form[&quot;user&quot;]) # Oldboy    print(request.form.get(&quot;pwd&quot;)) # DragonFire    #看来全部才对了, ImmutableMultiDict似乎就是个字典，再来玩一 玩它print(list(request.form.keys()) # [&apos;user&apos;, &apos;pwd&apos;] 看来是又才对了    return &quot;OK Hello World&quot;</code></pre><h3 id="request-method"><a href="#request-method" class="headerlink" title="request.method"></a>request.method</h3><p>request.method 知道前端用什么方式提交的<br>Flask的request中给我们提供了一个method属性里面包含了前端请求的方式<br><code>print(request.method)  # post</code></p><h3 id="request-form"><a href="#request-form" class="headerlink" title="request.form"></a>request.form</h3><pre><code>Form表单中传递过来的值使用request.form拿到print(request.form)  # ImmutableMultiDict([(&apos;user&apos;, &apos;Oldboy&apos;), (&apos;pwd&apos;, &apos;DragonFire&apos;)])# ImmutableMultiDict 它看起来像是的Dict 就用Dict的方法取值试一下吧print(request.form[&quot;user&quot;])  # Oldboyprint(request.form.get(&quot;pwd&quot;))  # DragonFire# 看来全部才对了, ImmutableMultiDict 似乎就是个字典,再来玩一玩它print(list(request.form.keys()))  # [&apos;user&apos;, &apos;pwd&apos;] 看来是又才对了#如果以上所有的方法你都觉得用的不爽的话req_dict = dict(request.form)print(req_dict)  # 如果你觉得用字典更爽的话,也可以转成字典操作(这里有坑)</code></pre><h3 id="request-args"><a href="#request-args" class="headerlink" title="request.args"></a>request.args</h3><p>request.args中保存的是url中传递的参数</p><pre><code>print(request.args)  # ImmutableMultiDict([(&apos;id&apos;, &apos;1&apos;), (&apos;age&apos;, &apos;20&apos;)])print(request.args[&quot;id&quot;])  # 1print(request.args.get(&quot;age&quot;))  # 20print(list(request.args.keys()))  # [&apos;id&apos;, &apos;age&apos;]print(list(request.args.values()))  # [&apos;1&apos;, &apos;20&apos;]req_dict = dict(request.args)  # {&apos;id&apos;: [&apos;1&apos;], &apos;age&apos;: [&apos;20&apos;]}print(req_dict)</code></pre><blockquote><p>request.args 与 request.form 的区别就是:</p></blockquote><blockquote><blockquote><p>request.args 是获取url中的参数</p></blockquote></blockquote><blockquote><blockquote><p>request.form 是获取form表单中的参数</p></blockquote></blockquote><h3 id="request-values"><a href="#request-values" class="headerlink" title="request.values"></a>request.values</h3><p>request.values 只要是参数都需要</p><p>修改下前端代码</p><pre><code>&lt;body&gt;&lt;form action=&quot;/login?id=1&amp;age=20&quot; method=&quot;post&quot;&gt;    &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt;    &lt;p&gt;密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;/p&gt;    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt;</code></pre><p>使用form表单提交的同时使用url参数提交</p><pre><code>print(request.values)  # CombinedMultiDict([ImmutableMultiDict([(&apos;id&apos;, &apos;1&apos;), (&apos;age&apos;, &apos;20&apos;)]), ImmutableMultiDict([(&apos;user&apos;, &apos;Oldboy&apos;), (&apos;pwd&apos;, &apos;DragonFire&apos;)])])print(request.values.get(&quot;id&quot;))  # 1print(request.values[&quot;user&quot;])  # Oldboy# 这回喜欢直接操作字典的小伙伴们有惊喜了! to_dict() 方法可以直接将我们的参数全部转为字典形式print(request.values.to_dict()) # {&apos;user&apos;: &apos;Oldboy&apos;, &apos;pwd&apos;: &apos;DragonFire&apos;, &apos;id&apos;: &apos;1&apos;, &apos;age&apos;: &apos;20&apos;}</code></pre><h3 id="request-headers"><a href="#request-headers" class="headerlink" title="request.headers"></a>request.headers</h3><p>request.headers  获取请求头</p><pre><code>print(type(request.headers))    &quot;&quot;&quot;    Host: 127.0.0.1:5000    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8    Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2    Accept-Encoding: gzip, deflate    Referer: http://127.0.0.1:5000/home    Content-Type: application/x-www-form-urlencoded    Content-Length: 26    Cookie: csrftoken=vDIozqveCEfArdYXlM6goHVlSQEn7h4bDygNphL2Feas60DiM2di0jlqKfxo7xhA    Connection: keep-alive    Upgrade-Insecure-Requests: 1    Cache-Control: max-age=0    &quot;&quot;&quot;</code></pre><h3 id="request-files"><a href="#request-files" class="headerlink" title="request.files"></a>request.files</h3><p>request.files 可上传文件</p><p>前端代码：</p><pre><code>&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot; enctype=&apos;multipart/form-data&apos;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;</code></pre><p>后端代码：</p><pre><code>print(request.files)  # ImmutableMultiDict([(&apos;file&apos;, &lt;FileStorage: &apos;DragonFire.txt&apos; (&apos;text/plain&apos;)&gt;)])print(request.files[&quot;file&quot;])  # &lt;FileStorage: &apos;DragonFire.txt&apos; (&apos;text/plain&apos;)&gt;my_file = request.files[&quot;file&quot;]my_file.save(&quot;zuobangzheng.txt&quot;)  # 保存文件,里面可以写完整路径+文件名print(request.values)  # CombinedMultiDict([ImmutableMultiDict([(&apos;id&apos;, &apos;1&apos;), (&apos;age&apos;, &apos;20&apos;)]), ImmutableMultiDict([(&apos;user&apos;, &apos;zuo&apos;), (&apos;pwd&apos;, &apos;123&apos;)])])print(request.values.get(&quot;id&quot;))  # 1print(request.values[&quot;user&quot;])  # zuo# 这回喜欢直接操作字典的小伙伴们有惊喜了! to_dict() 方法可以直接将我们的参数全部转为字典形式print(request.values.to_dict()) # {&apos;user&apos;: &apos;zuo&apos;, &apos;pwd&apos;: &apos;123&apos;, &apos;id&apos;: &apos;1&apos;, &apos;age&apos;: &apos;20&apos;}</code></pre><p>最后这样就可以保存文件了</p><h3 id="request-获取各种路径"><a href="#request-获取各种路径" class="headerlink" title="request.获取各种路径"></a>request.获取各种路径</h3><pre><code># 获取当前的url路径print(request.path)  # /req# 当前url路径的上一级路径print(request.script_root)  ## 当前url的全部路径print(request.url)  # http://127.0.0.1:5000/req# 当前url的路径的上一级全部路径print(request.url_root)  # http://127.0.0.1:5000/</code></pre><h3 id="request-json"><a href="#request-json" class="headerlink" title="request.json"></a>request.json</h3><p>如果在请求中写入了 “application/json” 使用 request.json 则返回json解析数据, 否则返回 None</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每个框架斗鱼处理请求的机制(request)，但每个框架的处理方式和机制是不同的&lt;/p&gt;
&lt;h3 id=&quot;认识request包含的内容&quot;&gt;&lt;a href=&quot;#认识request包含的内容&quot; class=&quot;headerlink&quot; title=&quot;认识request包含的内容&quot;&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://fireworksrain.com/categories/Python/"/>
    
    
      <category term="Flask框架" scheme="http://fireworksrain.com/tags/Flask%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Flask初识</title>
    <link href="http://fireworksrain.com/Flask%E5%88%9D%E8%AF%86/"/>
    <id>http://fireworksrain.com/Flask初识/</id>
    <published>2017-11-27T08:05:14.000Z</published>
    <updated>2018-11-27T09:53:24.608Z</updated>
    
    <content type="html"><![CDATA[<p>整体Flask框架思维导图<br><a href="https://www.processon.com/mindmap/5bdade0de4b0e452133637d9" title="Flask框架思维导图" target="_blank" rel="noopener">https://www.processon.com/mindmap/5bdade0de4b0e452133637d9</a></p><h3 id="Python-现阶段三大主流Web框架及比较"><a href="#Python-现阶段三大主流Web框架及比较" class="headerlink" title="Python 现阶段三大主流Web框架及比较"></a>Python 现阶段三大主流Web框架及比较</h3><blockquote><p>Django主要特点是大而全，集成很多组件，属于全能型框架。用于大型Web应用，但是会造成一部分资源浪费<br>Tornado主要特点是原生异步非阻塞，在IO密集型应用和多任务处理上占据绝对性的优势，属于专注型框架。用于API后端应用，如游戏服务后台，但是太过干净没有session<br>Flask主要特点小而轻，原生组件几乎为零，三方库非常全面，属于短小精悍框架。</p></blockquote><h3 id="Flask的安装与简单测试"><a href="#Flask的安装与简单测试" class="headerlink" title="Flask的安装与简单测试"></a>Flask的安装与简单测试</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>一条命令就足以安装成功：<br><code>pip install Flask</code></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>1.最简单三行测试：</p><pre><code>from flask import Flask #导入flask模块app = Flask(__name__);app.run()</code></pre><p>2.六行代码实现flask的helloworld</p><ul><li><p>1.简单写法：</p><pre><code>from flask import Flaskapp = Flask(__name__)</code></pre></li></ul><pre><code>@app.route(&quot;/&quot;)  # app中的route装饰器def index():    return &quot;Hello World&quot;app.run()  # 启动Flask Web服务</code></pre><ul><li><p>2.按照源码书写：</p><pre><code>from flask import Flaskapp = Flask(__name__)</code></pre></li></ul><pre><code>@app.route(&quot;/&quot;)  # app中的route装饰器def index():    return &quot;Hello World&quot;app.run()  # 启动Flask Web服务</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整体Flask框架思维导图&lt;br&gt;&lt;a href=&quot;https://www.processon.com/mindmap/5bdade0de4b0e452133637d9&quot; title=&quot;Flask框架思维导图&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://fireworksrain.com/categories/Python/"/>
    
    
      <category term="Flask框架" scheme="http://fireworksrain.com/tags/Flask%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>爬虫重点知识梳理</title>
    <link href="http://fireworksrain.com/%E7%88%AC%E8%99%AB%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <id>http://fireworksrain.com/爬虫重点知识梳理/</id>
    <published>2017-11-26T03:17:03.000Z</published>
    <updated>2018-11-26T14:11:24.637Z</updated>
    
    <content type="html"><![CDATA[<h3 id="requests模块重点梳理"><a href="#requests模块重点梳理" class="headerlink" title="requests模块重点梳理"></a>requests模块重点梳理</h3><h4 id="1-robots协议"><a href="#1-robots协议" class="headerlink" title="1.robots协议"></a>1.robots协议</h4><p>Robots协议(也称为爬虫协议、爬虫规则、机器人协议等)也就是robots.txt，网站通过robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。<br>Robots协议是网站国际互联网界通信的道德规范，其目的是保护网站数据和敏感信息，确保用户个人信息和个人隐私不被侵犯。因其不是命令，故需要搜索引擎自觉遵守。</p><h4 id="2-python网络爬虫所用到的网络数据包"><a href="#2-python网络爬虫所用到的网络数据包" class="headerlink" title="2.python网络爬虫所用到的网络数据包"></a>2.python网络爬虫所用到的网络数据包</h4><blockquote><p>requests   ，urllib</p></blockquote><h4 id="3-http、https协议的区别"><a href="#3-http、https协议的区别" class="headerlink" title="3.http、https协议的区别"></a>3.http、https协议的区别</h4><p>http协议是超文本传输协议，被用于在web浏览器和网站服务器之间传递信息。http协议工作是以明文方式发送内容，不提供任何形式的数据加密，而这也是很容易被黑客利用的地方，如果黑客截取了web浏览器和网站服务器之间的传输信息，就可以直接读懂其中的信息，因此http协议不适合传输一些重要的、敏感的信息，比如信用卡密码及支付验证码等。安全套接字层https协议就是为了解决http协议的这一安全缺陷而出生的，为了数据传输的安全，https在http的基础上加入了ssl协议，ssl依靠证书来验证服务器的身份，为浏览器和服务器之间的通信加密，这样的话即使黑客借去了发送过程中的信息，也无法破解读懂它，我们网站及用户的信息便得到了最大的安全保障。</p><h4 id="4-写爬虫时遇到的反爬措施以及解决方案"><a href="#4-写爬虫时遇到的反爬措施以及解决方案" class="headerlink" title="4.写爬虫时遇到的反爬措施以及解决方案"></a>4.写爬虫时遇到的反爬措施以及解决方案</h4><p>反爬措施：</p><blockquote><p>1.通过headers反爬虫<br>2.基于用户行为的反爬虫（同一IP短时间内访问的频率）<br>3.动态网页反爬虫(通过ajax请求数据，或者通过JavaScript生成)<br>4.验证码<br>数据加密</p></blockquote><p>解决途径：</p><blockquote><p>1.对于基本网页的抓取可以自定义headers,将header随request一起发送（一般是User-Agent，Cookie）<br>2.使用IP代理池爬取或者降低抓取频率<br>3.使用selenium + phantomjs 进行抓取抓取动态数据，或者找到动态数据加载的json页面<br>4.使用打码平台识别验证码<br>对部分数据进行加密的，可以使用selenium进行截图，使用python自带的pytesseract库进行识别，但是比较慢最直接的方法是找到加密的方法进行逆向推理。</p></blockquote><h4 id="4-POST与GET的区别"><a href="#4-POST与GET的区别" class="headerlink" title="4.POST与GET的区别"></a>4.POST与GET的区别</h4><p> GET数据传输安全性低，POST传输数据安全性高，因为参数不会被保存在浏览器历史或web服务器日志中；<br>在做数据查询时，建议用GET方式；而在做数据添加、修改或删除时，建议用POST方式；<br>GET在url中传递数据，数据信息放在请求头中；而POST请求信息放在请求体中进行传递数据；<br>GET传输数据的数据量较小，只能在请求头中发送数据，而POST传输数据信息比较大，一般不受限制；<br>在执行效率来说，GET比POST好</p><h4 id="5-为什么使用代理IP，常用代理ip网站"><a href="#5-为什么使用代理IP，常用代理ip网站" class="headerlink" title="5.为什么使用代理IP，常用代理ip网站"></a>5.为什么使用代理IP，常用代理ip网站</h4><p>网站的反爬虫策略会检测到同一个IP访问次数频率过快，从而禁止该IP的访问。因此爬虫过程中需要IP代理避免该问题。<br>常用代理IP网站：</p><blockquote><p>1.全国代理IP网<br>2.西祠代理网<br>3.快代理网</p></blockquote><h3 id="数据解析重点梳理"><a href="#数据解析重点梳理" class="headerlink" title="数据解析重点梳理"></a>数据解析重点梳理</h3><h4 id="1-使用正则对页面源码数据进行解析时，应该使用re-S还是Re-M？"><a href="#1-使用正则对页面源码数据进行解析时，应该使用re-S还是Re-M？" class="headerlink" title="1.使用正则对页面源码数据进行解析时，应该使用re.S还是Re.M？"></a>1.使用正则对页面源码数据进行解析时，应该使用re.S还是Re.M？</h4><p>re.S为单行解析，解析的源码数据中可以有换行符，re.S会作用到整个被视为一个大字符串的页面源码数据中。Re.M为多行解析，会将正则作用到源码的每一行中。在实战中使用的是re.S。</p><h4 id="2-xpath插件的作用"><a href="#2-xpath插件的作用" class="headerlink" title="2.xpath插件的作用"></a>2.xpath插件的作用</h4><p>可以直接在浏览器中直接校验xpath表达式，校验成功后再将xpath作用到程序中。</p><h4 id="3-xpath基础表达式"><a href="#3-xpath基础表达式" class="headerlink" title="3.xpath基础表达式"></a>3.xpath基础表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">层级索引定位：//div[@id=’xxx’]/a[2]/span</span><br><span class="line">逻辑运算：//a[@href=’’and @class=’xxx’]</span><br><span class="line">模糊匹配：//div[contains(@class,’xx’)]</span><br><span class="line">模糊匹配：//div[starts-with(@class,’xx’)]</span><br><span class="line">取文本：/div/text()  or /div//text()</span><br><span class="line">取属性：/@属性</span><br></pre></td></tr></table></figure><h4 id="4-bs4解析常用方法"><a href="#4-bs4解析常用方法" class="headerlink" title="4.bs4解析常用方法"></a>4.bs4解析常用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find_all():找到所有符合要求的标签</span><br><span class="line">select():根据选择器找到符合要求的标签</span><br><span class="line">1.多层级选择器：div a ul li</span><br><span class="line">2.单层层级选择器：div &gt; a &gt; ul &gt; li</span><br></pre></td></tr></table></figure><h3 id="打码平台使用流程"><a href="#打码平台使用流程" class="headerlink" title="打码平台使用流程"></a>打码平台使用流程</h3><blockquote><p>1.对携带验证码的页面数据进行抓取<br>2.将页面中的验证码进行解析，将验证码图片下载到本地<br>3.将验证码图片提交给打码平台进行识别，返回识别后的结果<br>打码平台的使用步骤：<br>1.在官网中进行普通用户和开发者用户注册<br>2.登陆开发者用户：</p></blockquote><pre><code>* 示例代码下载：开发文档--&gt;调用实例即最新DLL-PythonHTTP示例下载* 创建一个软件：我的软件 --&gt;添加新的软件(后期会使用该软件的密钥和ID)</code></pre><blockquote><p>3.使用示例代码中的示例代码对保存在本地的验证码进行识别</p></blockquote><h3 id="移动端数据的爬取"><a href="#移动端数据的爬取" class="headerlink" title="移动端数据的爬取"></a>移动端数据的爬取</h3><p>博客地址：</p><p>1.fiddler的设置：</p><ul><li>端口号和允许抓取其他机器上的数据包的设置</li><li>https数据包抓取的位置</li></ul><p>2.fiddler证书下载：</p><pre><code>* 保证手机和fiddler所在的机器处在同一网段下* 下载安全证书，且安装到手机上。在手机浏览器中录入fiddler机器的ip和fiddler的端口号进行证书的下载* 下载成功后进行证书的安装</code></pre><p>3.局域网设置：</p><pre><code>* 将手机的网络和端口后设置长fiddler电脑的ip和fiddler的端口号</code></pre><p>4.测试：</p><pre><code>* 开启fiddler，抓取手机请求的网络包</code></pre><h3 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h3><h4 id="1-持久化存储操作："><a href="#1-持久化存储操作：" class="headerlink" title="1.持久化存储操作："></a>1.持久化存储操作：</h4><p>1.基于终端指令的持久化存储</p><ul><li>scrapy crawl spiderName –o file</li></ul><p>2.基于管道的持久化存储</p><ul><li>1.将爬取到的数据封装在item对象中</li><li>2.使用yield将item提交给管道</li><li>3.在管道文件中的process_item方法中，将item中的数据进行持久化存储操作</li></ul><h4 id="2-基于scrapy的请求："><a href="#2-基于scrapy的请求：" class="headerlink" title="2.基于scrapy的请求："></a>2.基于scrapy的请求：</h4><p>1.手动get请求发送：yield scrapy.Request(url,callback)</p><ul><li>1.url:请求的url</li><li>2.callback：指定方法对请求到的页面进行解析操作</li></ul><p>2.post请求发送：</p><ul><li>1.重写父类的start_request方法，该方法会被调度器默认调用，在该方法中可以通过yield scrapy FormeRrequest（url，callback，formdata）进行post请求发送。<ul><li>a)参数formdata为post请求携带的参数，类型为字典。</li></ul></li></ul><h4 id="3-请求传参的使用："><a href="#3-请求传参的使用：" class="headerlink" title="3.请求传参的使用："></a>3.请求传参的使用：</h4><ul><li>当需求中需要解析的数据值不在同一个页面中时，必须用请求传参进行处理。</li><li>实现方式：yield scrapy.Request(url,callback,meta),使用meta参数可以将item对象传递给callback指定的回调方法中。meta为字典类型。</li></ul><p>####　4.UA池和代理池</p><p>1.使用UA池和代理池的目的：</p><ul><li>1.目的在于防止爬取网站的反爬虫策略</li></ul><p>2.UA池操作流程：<br>博客地址：</p><ul><li>1.在下载中间件中拦截请求</li><li>2.将拦截到的请求的请求头信息中的UA进行篡改伪装</li><li>3.在配置文件中开启中间件</li></ul><p>3.代理池操作流程：</p><ul><li>1.在下载中间件中拦截请求</li><li>2.将拦截到的请求ip修改成某一代理ip</li><li>3.在配置文件中开启中间件</li></ul><h4 id="5-scrapy中selenium的应用："><a href="#5-scrapy中selenium的应用：" class="headerlink" title="5.scrapy中selenium的应用："></a>5.scrapy中selenium的应用：</h4><p>博客地址：</p><p>1.原理分析：</p><ul><li>1.当引擎将国内板块url对应的请求提交给下载器后，下载器进行网页数据的下载，然后将下载到的页面数据，封装到response中，提交给引擎，引擎将response在转交给Spiders。Spiders接受到的response对象中存储的页面数据里是没有动态加载的新闻数据的。要想获取动态加载的新闻数据，则需要在下载中间件中对下载器提交给引擎的response响应对象进行拦截，切对其内部存储的页面数据进行篡改，修改成携带了动态加载出的新闻数据，然后将被篡改的response对象最终交给Spiders进行解析操作。</li></ul><p>2.selenium在scrapy中的使用流程：</p><ul><li>1.重写爬虫文件的构造方法，在该方法中使用selenium实例化一个浏览器对象（因为浏览器对象只需要被实例化一次）</li><li>2.重写爬虫文件的closed(self,spider)方法，在其内部关闭浏览器对象。该方法是在爬虫结束时被调用</li><li>3.重写下载中间件的process_response方法，让该方法对响应对象进行拦截，并篡改response中存储的页面数据</li><li>4.在配置文件中开启下载中间件</li></ul><p>3.分布式爬虫实现步骤：</p><ul><li>1.导包：</li></ul><p><code>from scrapy_redis.spiders import RedisCrawlSpider</code></p><ul><li><p>2.将爬虫类的父类修改成RedisCrawlSpider</p></li><li><p>3.将起始url列表注释，添加一个redis_key（调度器队列的名称）的属性</p></li><li><p>4.redis数据库配置文件的配置redisxxx.conf：</p><figure class="highlight plain"><figcaption><span>127.0.0.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b)protected-mode  no</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>5.对项目中settings进行配置：</p><ul><li><p>a)配置redis服务器的ip和端口号：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- b)配置使用scrapy-redis组件中的调度器</span><br><span class="line"></span><br><span class="line">    使用scrapy-redis组件的去重队列</span><br><span class="line">DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="line"># 使用scrapy-redis组件自己的调度器</span><br><span class="line">SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="line"># 是否允许暂停</span><br><span class="line">SCHEDULER_PERSIST = True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- c)配置使用scrapy-redis组件中的管道</span><br><span class="line"></span><br><span class="line">```ITEM_PIPELINES = &#123;#&apos;wangyiPro.pipelines.WangyiproPipeline&apos;: 300,</span><br><span class="line">    &apos;scrapy_redis.pipelines.RedisPipeline&apos;: 400,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>d)开启redis数据库的服务：redis-server 配置文件</p></li><li>e)执行爬虫文件：scrapy runspider wangyi.py</li><li>f)向调度器的队列中扔一个起始url：<ul><li>1.开启redis客户端</li><li>2.lpush 爬虫文件名称 起始url</li></ul></li></ul></li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>####　1.显著提升爬虫的效率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ii.使用光纤网络</span><br><span class="line">iii.多进程</span><br><span class="line">iv.多线程</span><br><span class="line">v.分布式</span><br></pre></td></tr></table></figure><h4 id="2-基于requests模块的多线程爬取建议大家使用："><a href="#2-基于requests模块的多线程爬取建议大家使用：" class="headerlink" title="2.基于requests模块的多线程爬取建议大家使用："></a>2.基于requests模块的多线程爬取建议大家使用：</h4><pre><code>multiprocessing.dummy.pool线程池，爬取效率会显著提升。</code></pre><p>简单代码示例：</p><pre><code>import requestsfrom bs4 import Beautiful#导入线程池from multiprocessing.dummy import Poolpool = Pool()#实例化线程池对象#发起首页请求page_text = requests.get(url=&apos;xxx&apos;)#使用bs4解析首页中所有的a标签soup = Beautiful(page_text)a_list = soup.select(&apos;a&apos;)#将a标签的href属性值和域名拼接，形成完整的urlurl_list = [&apos;www.xxx.com/&apos;+url[&apos;href&apos;] for url in a_list]#封装请求函数，该函数可以获取请求对应的页面数据request_page_text = lambda link:requests.get(link).text#使用线程池的map方法异步进行请求发送，切获取响应回来的页面数据page_text_list = pool.map(request_page_text, url_list)#使用线程池异步进行解析操作get_data = lambda data:parse(data)pool.map(get_data, page_text_list)#数据解析方法def parse(data):    pass</code></pre><h4 id="3-如何提升scrapy的爬取效率"><a href="#3-如何提升scrapy的爬取效率" class="headerlink" title="3.如何提升scrapy的爬取效率"></a>3.如何提升scrapy的爬取效率</h4><p>1.增加并发：</p><ul><li>1.默认scrapy开启的并发线程为32个，可以适当进行增加。在settings配置文件中修改CONCURRENT_REQUESTS = 100值为100,并发设置成了为100。</li></ul><p>2.降低日志级别：</p><ul><li>1.在运行scrapy时，会有大量日志信息的输出，为了减少CPU的使用率。可以设置log输出信息为INFO或者ERROR即可。在配置文件中编写：LOG_LEVEL = ‘INFO’</li></ul><p>3.禁止cookie：</p><ul><li>1.如果不是真的需要cookie，则在scrapy爬取数据时可以进制cookie从而减少CPU的使用率，提升爬取效率。在配置文件中编写：COOKIES_ENABLED = False</li></ul><p>4.禁止重试：</p><ul><li>1.对失败的HTTP进行重新请求（重试）会减慢爬取速度，因此可以禁止重试。在配置文件中编写：RETRY_ENABLED = False</li></ul><p>5.减少下载超时：</p><ul><li>1.如果对一个非常慢的链接进行爬取，减少下载超时可以能让卡住的链接快速被放弃，从而提升效率。在配置文件中进行编写：DOWNLOAD_TIMEOUT = 10 超时时间为10s</li></ul><h3 id="简历中爬虫项目的编写"><a href="#简历中爬虫项目的编写" class="headerlink" title="简历中爬虫项目的编写"></a>简历中爬虫项目的编写</h3><h4 id="1-关于爬取数据类型的问题："><a href="#1-关于爬取数据类型的问题：" class="headerlink" title="1.关于爬取数据类型的问题："></a>1.关于爬取数据类型的问题：</h4><p>1.常见的爬取数据类型有：</p><ul><li><p>1.电商类的商品信息</p><ul><li>a)数据来源网站：京东，天猫</li></ul></li><li><p>2.资讯类的新闻信息</p><p>  -a)网易新闻，腾讯新闻，今日头条等</p></li><li><p>3.音乐类的歌词、歌名、作者信息</p><ul><li>a)网易音乐，qq音乐等</li></ul></li><li><p>4.医疗器械类的参数信息</p><ul><li><p>a)3618医疗器械网：<a href="http://www.3618med.com/product" target="_blank" rel="noopener">http://www.3618med.com/product</a></p></li><li><p>b)中国医疗信息网:</p><ul><li>i.<a href="http://cmdi.gov.cn/publish/default/" target="_blank" rel="noopener">http://cmdi.gov.cn/publish/default/</a></li></ul></li></ul></li><li><p>5.气象类的天气信息</p><ul><li><p>a)中国空气质量在线检测分析平台</p><ul><li>i.<a href="https://www.aqistudy.cn/" target="_blank" rel="noopener">https://www.aqistudy.cn/</a></li></ul></li></ul></li></ul><p>####　2.爬取数据量级的问题：</p><ul><li><p>1.针对于百万量级的数据：</p><ul><li><p>a)基于requests模块进行爬取，时长为20小时左右</p></li><li><p>b)基于分布式机群（3台），时长为2小时左右</p></li><li><p>c)一般公司生产环节中，数据量过百万，则一般会使用分布式进行数据爬取。</p></li></ul></li></ul><h4 id="3-简历中相关爬虫项目（Demo）："><a href="#3-简历中相关爬虫项目（Demo）：" class="headerlink" title="3.简历中相关爬虫项目（Demo）："></a>3.简历中相关爬虫项目（Demo）：</h4><p>1.项目名称：潮流穿衣搭配数据采集</p><p>2.项目描述：</p><pre><code>1.本项目采用scrapy框架对爱搭配网和穿衣打扮网等网站导航页下所有大类、小类中的相关子链接，以及链接页面的相关内容进行爬取，将数据写入数据库，提供给公司做参考数据。</code></pre><p>3.责任描述：</p><pre><code>1.负责信息数据的爬取2.负责分析数据爬取的过程3.负责分析网站的反爬技术，并提供反反爬策略4.采用线程池进行数据爬取，采集了13w条数据5.负责将采集到的数据进行数据分析整理</code></pre><h4 id="4-简历示例"><a href="#4-简历示例" class="headerlink" title="4. 简历示例"></a>4. 简历示例</h4><p>项目名称：xxx新闻推荐系统数据采集</p><p>项目描述：</p><pre><code>AI接口进行关键字提取和文章分类检索。设计库表进行数据存储。</code></pre><p>3.责任描述：</p><pre><code>1.搭建5台分布式机群进行新闻数据爬取2.分析数据爬取过程，设计反反爬策略3.将分布爬取到的近30w条数据进行数据清洗和异常值过滤4.调用百度AI对新闻数据进行关键字提取和文章分类</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;requests模块重点梳理&quot;&gt;&lt;a href=&quot;#requests模块重点梳理&quot; class=&quot;headerlink&quot; title=&quot;requests模块重点梳理&quot;&gt;&lt;/a&gt;requests模块重点梳理&lt;/h3&gt;&lt;h4 id=&quot;1-robots协议&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Python" scheme="http://fireworksrain.com/categories/Python/"/>
    
    
      <category term="爬虫" scheme="http://fireworksrain.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Django模版系统</title>
    <link href="http://fireworksrain.com/Django%E6%A8%A1%E7%89%88%E7%B3%BB%E7%BB%9F/"/>
    <id>http://fireworksrain.com/Django模版系统/</id>
    <published>2017-01-05T02:59:18.000Z</published>
    <updated>2019-01-05T03:25:47.344Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.djangoproject.com/en/1.11/ref/templates/language/" target="_blank" rel="noopener">官方文档</a></p><h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><p>Django模版中只需要记两种特殊符号：</p><pre><code>{{}} 和{% %}{{}} 表示变量，在模版渲染的时候替换成值{% %} 表示逻辑相关的操作</code></pre><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>{{变量名}}</code></pre><p>变量名由字母数字和下划线组成<br>点(.)在模版语言中有特殊的含义，用来获取对象的相应属性值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/1.11/ref/templates/language/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用语法&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Python" scheme="http://fireworksrain.com/categories/Python/"/>
    
    
      <category term="Django框架" scheme="http://fireworksrain.com/tags/Django%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Django的简介</title>
    <link href="http://fireworksrain.com/Django%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
    <id>http://fireworksrain.com/Django的简介/</id>
    <published>2017-01-02T08:24:58.000Z</published>
    <updated>2019-01-04T08:26:33.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MVC框架和MTV框架"><a href="#MVC框架和MTV框架" class="headerlink" title="MVC框架和MTV框架"></a>MVC框架和MTV框架</h3><p>MVC：全名是Model View Controller，是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型(Model)、视图(View)和控制器(Controller)，具有耦合性低、重用性高、生命周期成本低等优点。<br>大体上是这样的：<br><img src="https://images2017.cnblogs.com/blog/867021/201801/867021-20180116155130396-1611801504.png" alt=""></p><p>Django框架的设计模式借鉴了MVC框架的思想，也分为三个部分，用来降低各个部分之间的耦合性。<br>Django框架的不同之处在于它拆分的三个部分：Model（模型）、Template（模板）和View（视图），也就是MTV框架。</p><h3 id="Django的MTV模式"><a href="#Django的MTV模式" class="headerlink" title="Django的MTV模式"></a>Django的MTV模式</h3><p> Model(模型)：负责业务对象与数据库的对象(ORM)</p><p> Template(模版)：负责如何把页面展示给用户</p><p> View(视图)：负责业务逻辑，并在适当的时候调用Model和Template</p><p>此外，Django还有一个urls分发器，它的作用是将一个个URL的页面请求分发给不同的view处理，view再调用相应的Model和Template</p><h3 id="Django框架图示"><a href="#Django框架图示" class="headerlink" title="Django框架图示"></a>Django框架图示</h3><p><img src="https://images2017.cnblogs.com/blog/867021/201801/867021-20180116155153334-721949851.png" alt=""></p><h3 id="Django常见命令"><a href="#Django常见命令" class="headerlink" title="Django常见命令"></a>Django常见命令</h3><p>在Django的使用过程中需要使用命令让Django进行一些早做，比如创建Django项目、启动Django程序、创建新的APP等</p><h4 id="1-创建Django项目"><a href="#1-创建Django项目" class="headerlink" title="1.创建Django项目"></a>1.创建Django项目</h4><p>一把我们都新建一个文件夹来存放项目文件，切换到这个目录下，启动命令行工具。创建一个名为xxx的Django项目：</p><pre><code>django-admin startproject xxx</code></pre><p>创建好项目后，可以查看当前目录下多出一个名为xxx的文件，xxx的文件夹目录结构如下：</p><pre><code>xxx/    manage.py    xxx/        __init__.py        settings.py        urls.py        wsgi.py</code></pre><h4 id="2-启动Django项目"><a href="#2-启动Django项目" class="headerlink" title="2.启动Django项目"></a>2.启动Django项目</h4><p>启动项目的时候，需要切换到xxx目录下，执行命令如下：</p><pre><code>python manage.py runserver　　#默认使用8000端口</code></pre><p>命令后面可以跟指定端口号:</p><pre><code>python manage.py runserver 8888　　#默认使用8888</code></pre><p>或者IP：</p><pre><code>python manage.py runserver 127.0.0.1:8000    #指定IP和端口，冒号分割</code></pre><h4 id="3-创建app"><a href="#3-创建app" class="headerlink" title="3.创建app"></a>3.创建app</h4><p>一个Django项目可以分为很多个app用来隔离不同功能模块的代码<br>命令行创建：</p><pre><code>python manage.py startapp app01</code></pre><p>执行后，项目目录下多出一个app01的文件夹，结构如下：</p><pre><code>app01/    migrations        __init__.py    __init__.py    admin.py    apps.py    models.py    tests.py    views.py</code></pre><h3 id="使用PyCharm创建"><a href="#使用PyCharm创建" class="headerlink" title="使用PyCharm创建"></a>使用PyCharm创建</h3><p>可以使用PyCharm的manage.py工具来执行命名。在主菜单栏中选择<strong>Tools</strong>，在下拉菜单中选择<strong>Run manage.py task</strong>，</p><p>在弹出的命令窗口中直接输入下面的命令便可创建app：</p><pre><code>startapp app01</code></pre><p>使用PyCharm的manage.py工具执行命令时，只用输入命令及参数即可，不再输入python manage.py了。</p><h4 id="1-数据库迁移"><a href="#1-数据库迁移" class="headerlink" title="1.数据库迁移"></a>1.数据库迁移</h4><pre><code>python manage.py makemigrationspython manage.py migrate</code></pre><h4 id="2-创建超级用户"><a href="#2-创建超级用户" class="headerlink" title="2.创建超级用户"></a>2.创建超级用户</h4><pre><code>python manage.py createsuperuser</code></pre><p>输入以上命令后，根据提示输入用户名、邮箱、密码、确认密码。密码的要求至少是不八位，不能和邮箱太接近，两次密码需要一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MVC框架和MTV框架&quot;&gt;&lt;a href=&quot;#MVC框架和MTV框架&quot; class=&quot;headerlink&quot; title=&quot;MVC框架和MTV框架&quot;&gt;&lt;/a&gt;MVC框架和MTV框架&lt;/h3&gt;&lt;p&gt;MVC：全名是Model View Controller，是软件工程
      
    
    </summary>
    
      <category term="Python" scheme="http://fireworksrain.com/categories/Python/"/>
    
    
      <category term="Django框架" scheme="http://fireworksrain.com/tags/Django%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>网络变成与并发知识小结</title>
    <link href="http://fireworksrain.com/%E7%BD%91%E7%BB%9C%E5%8F%98%E6%88%90%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    <id>http://fireworksrain.com/网络变成与并发知识小结/</id>
    <published>2016-12-22T08:41:37.000Z</published>
    <updated>2018-12-22T08:45:00.374Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简述osi-7层模型"><a href="#1-简述osi-7层模型" class="headerlink" title="1.简述osi 7层模型"></a>1.简述osi 7层模型</h3><pre><code>应用层             py文件                 应用层 表示层 会话层传输层             udp、TCP协议       传输层网络层             IP协议                 网络层数据链路层        ARP协议              数据链路层物理层             网线等                 物理层</code></pre><h3 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h3><blockquote><ol><li>三次握手<br>客户端向服务器发送一个连接请求，服务端接收并同意连接并且在发送给客户端请求连接，客户端收到服务器发送的消息并同意<br>2.四次挥手<br>客户端向服务器主动发送断开请求，服务器接收并发送也要断开连接，服务器向客户端发送断开请求，客户端接收并同意断开</li></ol></blockquote><h3 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h3><p>TCP是可靠的、面向连接的协议、传输效率低、全双工通信、面向自己节流<br>UDP不可靠的、无连接的服务、传输效率高、一对一、一对多、多对多、多对一、面向报文、无拥塞控制。</p><h3 id="黏包显现"><a href="#黏包显现" class="headerlink" title="黏包显现"></a>黏包显现</h3><p>客户端向服务端发送数据会经过缓冲区，服务端接收但不能区分出数据。<br>可用struct模块实现对数据的封包</p><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>HTTP协议叫做超文本传输协议，基于TCP协议实现的，一次请求一次响应然后断开链接</p><pre><code>格式    请求        请求头            user-agent    设备信息            accept          接收的格式数据            content-type  发送请求体的格式            cookies         浏览器端的cookie信息            connection     告诉服务器保持连接状态 值keep alive            referer 将浏览器上次访问的地址发给服务器            请求方式：GET/POST..        请求体     响应        响应头            location 让用户重定向到指定url            set-cookies 给用户浏览器设置cookie            状态码：                200                300                400                500         响应体                用户能看到的内容</code></pre><h3 id="7-websocket协议"><a href="#7-websocket协议" class="headerlink" title="7.websocket协议"></a>7.websocket协议</h3><p><strong>服务器向客户端主动推送消息</strong><br>它是基于TCP协议实现的新的协议，连接后需要进行握手，连接不断开</p><pre><code>简单过程连接后进行握手    获取客户端发送过来的随机字符串：在请求Sec-WebSocket-Key中获取  加密：     base64.b64encode(hashlib.sha1(mnwFxiOlctXFN/DeMt1Amg== + magic string))    返回给客户浏览器，在响应头中设置：Sec-WebSocket-Key：加密后的值握手成功后，进行收发数据（加密的）：            - 127: 2+8字节   MASK（4字节）+数据        - 126: 2+2字节   MASK（4字节）+数据        - 125: 2字节     MASK（4字节）+数据返回数据加密</code></pre><h3 id="8-https协议"><a href="#8-https协议" class="headerlink" title="8.https协议"></a>8.https协议</h3><p>HTTPS协议叫做超文本传输安全协议，是以安全为目的的HTTP通道。HTTP下加入SSL层。端口号：443</p><h3 id="9-进程、线程、协程的区别"><a href="#9-进程、线程、协程的区别" class="headerlink" title="9.进程、线程、协程的区别"></a>9.进程、线程、协程的区别</h3><p>进程：计算机中资源分配的最小单元<br>线程：计算机CPU调度的最小单元。一个进程中可以创建多个线程，进程用于维护一个空间，线程则在此空间内进行工作。<br>协程：计算机中并不存在，由开发人员认为创造的。也称为“微线程”</p><h3 id="10-GIL锁"><a href="#10-GIL锁" class="headerlink" title="10. GIL锁"></a>10. GIL锁</h3><p>GIL锁叫做全局解释器锁，它保证了一个进程中统一时刻只有一个线程可以被CPU调度，保证不了数据的安全，可以通过RLock，Lock，Condition,Event来实现数据的安全。<br>应用：爬虫，进程+协程</p><h3 id="11-IO多路复用"><a href="#11-IO多路复用" class="headerlink" title="11.IO多路复用"></a>11.IO多路复用</h3><p>帮助开发者监听多个socket是否发生变化</p><pre><code>实现IO多路复用：        win：            select        linux：            select，个数最多为1024个，轮询检测            poll，轮询检测(水平触发)            epoll，回调通知(边缘触发)应用场景：wsgiref，socketuwsgi，socket+IO多路复用nginx，IO多路复用</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简述osi-7层模型&quot;&gt;&lt;a href=&quot;#1-简述osi-7层模型&quot; class=&quot;headerlink&quot; title=&quot;1.简述osi 7层模型&quot;&gt;&lt;/a&gt;1.简述osi 7层模型&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;应用层             py文件  
      
    
    </summary>
    
      <category term="Python" scheme="http://fireworksrain.com/categories/Python/"/>
    
    
      <category term="网络编程与并发" scheme="http://fireworksrain.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Python之Web框架原理</title>
    <link href="http://fireworksrain.com/Python%E4%B9%8BWeb%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://fireworksrain.com/Python之Web框架原理/</id>
    <published>2016-12-22T08:41:37.000Z</published>
    <updated>2019-01-01T12:02:13.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Web框架本质"><a href="#Web框架本质" class="headerlink" title="Web框架本质"></a>Web框架本质</h3><p>所有的Web本质上就是一个socket服务端，而用户的浏览器就是一个socket客户端，这样就可以实现Web框架</p><pre><code>socket服务端：import socket  sk = socket.socket()  sk.bind((&quot;127.0.0.1&quot;, 80))  sk.listen()  while True:      conn, addr = sk.accept()      data = conn.recv(8096)      conn.send(b&quot;OK&quot;)      conn.close()</code></pre><p>Web服务本质上其实就是这十几行代码的基础上扩展出来的。<br>用户在浏览器中输入网址，浏览器会向服务器发送数据，遵循一个规则，让彼此发送消息、结束消息都有一个格式。这个规则就是<strong>HTTP协议</strong>，浏览器发送请求信息，服务器响应消息，都遵循这个规则。</p><p>HTTP协议主要规定了客户端和服务器之间的通信格式。首先先打印我们在服务端接收道德消息是什么<br>    import socket    </p><pre><code>sk = socket.socket()    sk.bind((&quot;127.0.0.1&quot;, 80))    sk.listen()    while True:        conn, addr = sk.accept()        data = conn.recv(8096)        print(data)  # 将浏览器发来的消息打印出来        conn.send(b&quot;OK&quot;)        conn.close()   </code></pre><p>输出结果是：</p><pre><code>b&apos;GET / HTTP/1.1\r\nHost: 127.0.0.1:8080\r\nConnection: keep-alive\r\nCache-Control: max-age=0\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3355.4 Safari/537.36\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q=0.9\r\nCookie: csrftoken=CtHePYARJOKNx5oNVwxIteOJXpNyJ29L4bW4506YoVqFaIFFaHm0EWDZqKmw6Jm8\r\n\r\n&apos;</code></pre><p>这种样子比较复杂。我们可以试试把\r\n换成换行：</p><pre><code>GET / HTTP/1.1  Host: 127.0.0.1:8080  Connection: keep-alive  Cache-Control: max-age=0  Upgrade-Insecure-Requests: 1  User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3355.4 Safari/537.36  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8  Accept-Encoding: gzip, deflate, br  Accept-Language: zh-CN,zh;q=0.9  Cookie: csrftoken=CtHePYARJOKNx5oNVwxIteOJXpNyJ29L4bW4506YoVqFaIFFaHm0EWDZqKmw6Jm8  </code></pre><p>响应相关的信息可以在浏览器调试窗口的Network标签页中看到，点击<strong>view source</strong>之后就会有显示如上的信息。</p><p>HTTP协议对受发消息的格式要求，每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。HTTP响应的Header中有一个<strong>Content-Type</strong>表明响应的内容格式。</p><p><strong>HTTP GET请求的格式：</strong> 请求行 请求头部  请求数据</p><table><thead><tr><th>请求方法</th><th>空格</th><th>URL</th><th>空格</th><th>协议版本</th><th>回车符</th><th>换行符</th></tr></thead><tbody><tr><td>头部字段名</td><td>:</td><td>值</td><td>回车符</td><td>换行符</td></tr><tr><td>回车符</td><td>换行符</td></tr><tr><td>请求数据</td></tr></tbody></table><p><strong>HTTP响应的格式</strong> 状态行 响应头部 响应正文</p><table><thead><tr><th>协议版本</th><th>空格</th><th>状态码</th><th>空格</th><th>状态码描述</th><th>回车符</th><th>换行符</th></tr></thead><tbody><tr><td>头部字段名</td><td>:</td><td>值</td><td>回车符</td><td>换行符</td></tr><tr><td>回车符</td><td>换行符</td></tr><tr><td>响应正文</td></tr></tbody></table><h3 id="自定义Web框架"><a href="#自定义Web框架" class="headerlink" title="自定义Web框架"></a>自定义Web框架</h3><p>基于以上的知识内容，可以通过十几行代码可以实现。先不处理浏览器发送的请求，先让浏览器能显示web框架的返回信息</p><pre><code>import socket    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    sock.bind((&apos;127.0.0.1&apos;, 8000))    sock.listen()    while True:        conn, addr = sock.accept()        data = conn.recv(8096)        # 给回复的消息加上响应状态行        conn.send(b&quot;HTTP/1.1 200 OK\r\n\r\n&quot;)        conn.send(b&quot;OK&quot;)        conn.close()   </code></pre><p>这样十几行代码就可以简单的演示了Web框架的本质。接下来就可以继续的完善自己自定义的Web框架</p><h3 id="根据不同的路径返回不同的内容"><a href="#根据不同的路径返回不同的内容" class="headerlink" title="根据不同的路径返回不同的内容"></a>根据不同的路径返回不同的内容</h3><p>让我们的Web服务根据用户请求的URL不同来返回不同的内容。</p><pre><code>&quot;&quot;&quot; 根据URL中不同的路径返回不同的内容 &quot;&quot;&quot;  import socket  sk = socket.socket()  sk.bind((&quot;127.0.0.1&quot;, 8080))  # 绑定IP和端口  sk.listen()  # 监听  while True:      # 等待连接      conn, add = sk.accept()      data = conn.recv(8096)  # 接收客户端发来的消息      # 从data中取到路径      data = str(data, encoding=&quot;utf8&quot;)  # 把收到的字节类型的数据转换成字符串      # 按\r\n分割      data1 = data.split(&quot;\r\n&quot;)[0]      url = data1.split()[1]  # url是我们从浏览器发过来的消息中分离出的访问路径      conn.send(b&apos;HTTP/1.1 200 OK\r\n\r\n&apos;)  # 因为要遵循HTTP协议，所以回复的消息也要加状态行      # 根据不同的路径返回不同内容      if url == &quot;/index/&quot;:          response = b&quot;index&quot;      elif url == &quot;/home/&quot;:          response = b&quot;home&quot;      else:          response = b&quot;404 not found!&quot;      conn.send(response)      conn.close()</code></pre><h4 id="根据不同的路径返回不同的内容—函数版"><a href="#根据不同的路径返回不同的内容—函数版" class="headerlink" title="根据不同的路径返回不同的内容—函数版"></a>根据不同的路径返回不同的内容—函数版</h4><pre><code>&quot;&quot;&quot; 根据URL中不同的路径返回不同的内容--函数版 &quot;&quot;&quot;  import socket  sk = socket.socket()  sk.bind((&quot;127.0.0.1&quot;, 8080))  # 绑定IP和端口  sk.listen()  # 监听  # 将返回不同的内容部分封装成函数  def func(url):      s = &quot;这是{}页面！&quot;.format(url)      return bytes(s, encoding=&quot;utf8&quot;)  while True:      # 等待连接      conn, add = sk.accept()      data = conn.recv(8096)  # 接收客户端发来的消息      # 从data中取到路径      data = str(data, encoding=&quot;utf8&quot;)  # 把收到的字节类型的数据转换成字符串      # 按\r\n分割      data1 = data.split(&quot;\r\n&quot;)[0]      url = data1.split()[1]  # url是我们从浏览器发过来的消息中分离出的访问路径      conn.send(b&apos;HTTP/1.1 200 OK\r\n\r\n&apos;)  # 因为要遵循HTTP协议，所以回复的消息也要加状态行      # 根据不同的路径返回不同内容，response是具体的响应体      if url == &quot;/index/&quot;:          response = func(url)      elif url == &quot;/home/&quot;:          response = func(url)      else:          response = b&quot;404 not found!&quot;      conn.send(response)  </code></pre><h4 id="根据不同的路径返回不同的内容–函数进阶版"><a href="#根据不同的路径返回不同的内容–函数进阶版" class="headerlink" title="根据不同的路径返回不同的内容–函数进阶版"></a>根据不同的路径返回不同的内容–函数进阶版</h4><p>上面的代码写了一个函数，那就可以写很多函数，不同路径执行不同的函数得到结果，但需要去一一判断，所以有了以下</p><pre><code>&quot;&quot;&quot; 根据URL中不同的路径返回不同的内容--函数进阶版 &quot;&quot;&quot;  import socket  sk = socket.socket()  sk.bind((&quot;127.0.0.1&quot;, 8080))  # 绑定IP和端口  sk.listen()  # 监听  # 将返回不同的内容部分封装成不同的函数  def index(url):      s = &quot;这是{}页面XX！&quot;.format(url)      return bytes(s, encoding=&quot;utf8&quot;)  def home(url):      s = &quot;这是{}页面。。！&quot;.format(url)      return bytes(s, encoding=&quot;utf8&quot;)  # 定义一个url和实际要执行的函数的对应关系  list1 = [      (&quot;/index/&quot;, index),      (&quot;/home/&quot;, home),  ]  while True:      # 等待连接      conn, add = sk.accept()      data = conn.recv(8096)  # 接收客户端发来的消息      # 从data中取到路径      data = str(data, encoding=&quot;utf8&quot;)  # 把收到的字节类型的数据转换成字符串      # 按\r\n分割      data1 = data.split(&quot;\r\n&quot;)[0]      url = data1.split()[1]  # url是我们从浏览器发过来的消息中分离出的访问路径      conn.send(b&apos;HTTP/1.1 200 OK\r\n\r\n&apos;)  # 因为要遵循HTTP协议，所以回复的消息也要加状态行      # 根据不同的路径返回不同内容      func = None  # 定义一个保存将要执行的函数名的变量      for item in list1:          if item[0] == url:              func = item[1]              break      if func:          response = func(url)      else:          response = b&quot;404 not found!&quot;      # 返回具体的响应消息      conn.send(response)      conn.close()  </code></pre><h3 id="返回具体的HTML文件"><a href="#返回具体的HTML文件" class="headerlink" title="返回具体的HTML文件"></a>返回具体的HTML文件</h3><p>返回的内容都会转换成字节数据发送出去，打开HTML文件，读取它内部二进制数据，然后再发送给浏览器</p><pre><code>&quot;&quot;&quot; 根据URL中不同的路径返回不同的内容--函数进阶版 返回独立的HTML页面 &quot;&quot;&quot;  import socket  sk = socket.socket()  sk.bind((&quot;127.0.0.1&quot;, 8080))  # 绑定IP和端口  sk.listen()  # 监听  # 将返回不同的内容部分封装成不同的函数  def index(url):      # 读取index.html页面的内容      with open(&quot;index.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:          s = f.read()      # 返回字节数据      return bytes(s, encoding=&quot;utf8&quot;)  def home(url):      with open(&quot;home.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:          s = f.read()      return bytes(s, encoding=&quot;utf8&quot;)  # 定义一个url和实际要执行的函数的对应关系  list1 = [      (&quot;/index/&quot;, index),      (&quot;/home/&quot;, home),  ]  while True:      # 等待连接      conn, add = sk.accept()      data = conn.recv(8096)  # 接收客户端发来的消息      # 从data中取到路径      data = str(data, encoding=&quot;utf8&quot;)  # 把收到的字节类型的数据转换成字符串      # 按\r\n分割      data1 = data.split(&quot;\r\n&quot;)[0]      url = data1.split()[1]  # url是我们从浏览器发过来的消息中分离出的访问路径      conn.send(b&apos;HTTP/1.1 200 OK\r\n\r\n&apos;)  # 因为要遵循HTTP协议，所以回复的消息也要加状态行      # 根据不同的路径返回不同内容      func = None  # 定义一个保存将要执行的函数名的变量      for item in list1:          if item[0] == url:              func = item[1]              break      if func:          response = func(url)      else:          response = b&quot;404 not found!&quot;      # 返回具体的响应消息      conn.send(response)      conn.close()  </code></pre><p>上述代码中书写了两个不同的页面，我们可以设置以下：</p><p>一、index.html</p><pre><code>这是index.html 文件&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;这是index页面&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>二、home.html</p><pre><code>这是home.html 文件&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;这是home页面&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="制作一个动态网页"><a href="#制作一个动态网页" class="headerlink" title="制作一个动态网页"></a>制作一个动态网页</h3><p>上面的网页是一个静态网页，内容不是变化，想要一个动态网页，选择使用字符串替换来实现。用时间戳来模拟动态数据</p><pre><code>&quot;&quot;&quot; 根据URL中不同的路径返回不同的内容--函数进阶版 返回独立的HTML页面 &quot;&quot;&quot;  import socket  sk = socket.socket()  sk.bind((&quot;127.0.0.1&quot;, 8080))  # 绑定IP和端口  sk.listen()  # 监听  # 将返回不同的内容部分封装成不同的函数  def index(url):      # 读取index.html页面的内容      with open(&quot;index.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:          s = f.read()      # 返回字节数据      return bytes(s, encoding=&quot;utf8&quot;)  def home(url):      with open(&quot;home.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:          s = f.read()      return bytes(s, encoding=&quot;utf8&quot;)  def timer(url):      import time      with open(&quot;time.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:          s = f.read()          s = s.replace(&apos;@@time@@&apos;, time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;))      return bytes(s, encoding=&quot;utf8&quot;)  # 定义一个url和实际要执行的函数的对应关系  list1 = [      (&quot;/index/&quot;, index),      (&quot;/home/&quot;, home),      (&quot;/time/&quot;, timer),  ]  while True:      # 等待连接      conn, add = sk.accept()      data = conn.recv(8096)  # 接收客户端发来的消息      # 从data中取到路径      data = str(data, encoding=&quot;utf8&quot;)  # 把收到的字节类型的数据转换成字符串      # 按\r\n分割      data1 = data.split(&quot;\r\n&quot;)[0]      url = data1.split()[1]  # url是我们从浏览器发过来的消息中分离出的访问路径      conn.send(b&apos;HTTP/1.1 200 OK\r\n\r\n&apos;)  # 因为要遵循HTTP协议，所以回复的消息也要加状态行      # 根据不同的路径返回不同内容      func = None  # 定义一个保存将要执行的函数名的变量      for item in list1:          if item[0] == url:              func = item[1]              break      if func:          response = func(url)      else:          response = b&quot;404 not found!&quot;      # 返回具体的响应消息      conn.send(response)      conn.close()  </code></pre><h3 id="服务器程序和应用程序"><a href="#服务器程序和应用程序" class="headerlink" title="服务器程序和应用程序"></a>服务器程序和应用程序</h3><p>对于真实开发中的python web程序来说，一般会分为两部分：服务器程序和应用程序。</p><p>服务器程序负责对socket服务端进行封装，并在请求到来时，对请求的各种数据进行整理。</p><p>应用程序则负责具体的逻辑处理。为了方便应用程序的开发，就出现了众多的Web框架，例如：Django、Flask、web.py 等。不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。</p><p>这样，服务器程序就需要为不同的框架提供不同的支持。这样混乱的局面无论对于服务器还是框架，都是不好的。对服务器来说，需要支持各种不同框架，对框架来说，只有支持它的服务器才能被开发出的应用使用。</p><p>这时候，标准化就变得尤为重要。我们可以设立一个标准，只要服务器程序支持这个标准，框架也支持这个标准，那么他们就可以配合使用。一旦标准确定，双方各自实现。这样，服务器可以支持更多支持标准的框架，框架也可以使用更多支持标准的服务器。</p><p>WSGI（Web Server Gateway Interface）就是一种规范，它定义了使用Python编写的web应用程序与web服务器程序之间的接口格式，实现web应用程序与web服务器程序间的解耦。</p><p>常用的WSGI服务器有uwsgi、Gunicorn。而Python标准库提供的独立WSGI服务器叫wsgiref，Django开发环境用的就是这个模块来做服务器。</p><h3 id="wsgiref"><a href="#wsgiref" class="headerlink" title="wsgiref"></a>wsgiref</h3><p>我们利用wsgiref模块来替换自定义的web框架的socket server部分：</p><pre><code>&quot;&quot;&quot;  根据URL中不同的路径返回不同的内容--函数进阶版  返回HTML页面  让网页动态起来  wsgiref模块版  &quot;&quot;&quot;   from wsgiref.simple_server import make_server   # 将返回不同的内容部分封装成函数   def index(url):       # 读取index.html页面的内容       with open(&quot;index.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:           s = f.read()       # 返回字节数据       return bytes(s, encoding=&quot;utf8&quot;)   def home(url):       with open(&quot;home.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:           s = f.read()       return bytes(s, encoding=&quot;utf8&quot;)   def timer(url):       import time       with open(&quot;time.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:           s = f.read()           s = s.replace(&apos;@@time@@&apos;, time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;))       return bytes(s, encoding=&quot;utf8&quot;)   # 定义一个url和实际要执行的函数的对应关系   list1 = [       (&quot;/index/&quot;, index),       (&quot;/home/&quot;, home),       (&quot;/time/&quot;, timer),   ]   def run_server(environ, start_response):       start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html;charset=utf8&apos;), ])  # 设置HTTP响应的状态码和头信息       url = environ[&apos;PATH_INFO&apos;]  # 取到用户输入的url       func = None       for i in list1:           if i[0] == url:               func = i[1]               break       if func:           response = func(url)       else:           response = b&quot;404 not found!&quot;       return [response, ]   if __name__ == &apos;__main__&apos;:       httpd = make_server(&apos;127.0.0.1&apos;, 8090, run_server)       print(&quot;我在8090等你哦...&quot;)       httpd.serve_forever()  </code></pre><h3 id="jinja2"><a href="#jinja2" class="headerlink" title="jinja2"></a>jinja2</h3><p>上面的代码实现了一个简单的动态，我完全可以从数据库中查询数据，然后去替换我html中的对应内容，然后再发送给浏览器完成渲染。 这个过程就相当于HTML模板渲染数据。 本质上就是HTML内容中利用一些特殊的符号来替换要展示的数据。 我这里用的特殊符号是我定义的，其实模板渲染有个现成的工具： <strong>jinja2</strong></p><p>下载jinja2：<br>    pip install jinja2</p><p>准备一个inde2.html文件</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;姓名：{{name}}&lt;/h1&gt;    &lt;h1&gt;爱好：&lt;/h1&gt;    &lt;ul&gt;        {% for hobby in hobby_list %}        <li>{{hobby}}</li>        {% endfor %}    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>使用jinja2渲染index2.html文件</p><pre><code>from wsgiref.simple_server import make_server  from jinja2 import Template  def index(url):      # 读取HTML文件内容      with open(&quot;index2.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:          data = f.read()          template = Template(data)   # 生成模板文件          ret = template.render({&apos;name&apos;: &apos;alex&apos;, &apos;hobby_list&apos;: [&apos;抽烟&apos;, &apos;喝酒&apos;, &apos;烫头&apos;]})   # 把数据填充到模板中      return bytes(ret, encoding=&quot;utf8&quot;)  def home(url):      with open(&quot;home.html&quot;, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:          s = f.read()      return bytes(s, encoding=&quot;utf8&quot;)  # 定义一个url和实际要执行的函数的对应关系  list1 = [      (&quot;/index/&quot;, index),      (&quot;/home/&quot;, home),  ]  def run_server(environ, start_response):      start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html;charset=utf8&apos;), ])  # 设置HTTP响应的状态码和头信息      url = environ[&apos;PATH_INFO&apos;]  # 取到用户输入的url      func = None      for i in list1:          if i[0] == url:              func = i[1]              break      if func:          response = func(url)      else:          response = b&quot;404 not found!&quot;      return [response, ]  if __name__ == &apos;__main__&apos;:      httpd = make_server(&apos;127.0.0.1&apos;, 8090, run_server)      print(&quot;我在8090等你哦...&quot;)      httpd.serve_forever()  </code></pre><p>现在的数据都是自己手写的，Python是可以从数据库查询数据，如</p><pre><code>conn = pymysql.connect(host=&quot;127.0.0.1&quot;, port=3306, user=&quot;root&quot;, passwd=&quot;xxx&quot;, db=&quot;xxx&quot;, charset=&quot;utf8&quot;)cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)cursor.execute(&quot;select name, age, department_id from userinfo&quot;)user_list = cursor.fetchall()cursor.close()conn.close()</code></pre><p>上述代码是需要一个userinfo：</p><pre><code>CREATE TABLE user(  id int auto_increment PRIMARY KEY,  name CHAR(10) NOT NULL,  hobby CHAR(20) NOT NULL)engine=innodb DEFAULT charset=UTF8;</code></pre><p><strong>模版的原理就是字符串替换，只要在HTML页面中遵循jinja2的语法规则写上，其内部就会按照指定的语法进行相应的替换，从而达到动态的返回内容</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Web框架本质&quot;&gt;&lt;a href=&quot;#Web框架本质&quot; class=&quot;headerlink&quot; title=&quot;Web框架本质&quot;&gt;&lt;/a&gt;Web框架本质&lt;/h3&gt;&lt;p&gt;所有的Web本质上就是一个socket服务端，而用户的浏览器就是一个socket客户端，这样就可以实
      
    
    </summary>
    
      <category term="Python" scheme="http://fireworksrain.com/categories/Python/"/>
    
    
      <category term="Web框架原理" scheme="http://fireworksrain.com/tags/Web%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>前端CSS形状</title>
    <link href="http://fireworksrain.com/%E5%89%8D%E7%AB%AFCSS%E5%BD%A2%E7%8A%B6/"/>
    <id>http://fireworksrain.com/前端CSS形状/</id>
    <published>2016-06-22T03:31:10.000Z</published>
    <updated>2019-06-28T04:46:25.785Z</updated>
    
    <content type="html"><![CDATA[<p>对于现在来讲，有很多的软件可以实现一些图标的样式，但是我们可以去学习那种思路和方法</p><h3 id="1-正方形"><a href="#1-正方形" class="headerlink" title="1.正方形"></a>1.正方形</h3><p><img src="/前端CSS形状/1.png" alt=""></p><pre><code>#square {         width: 100px;         height: 100px;         background: red;        }</code></pre><h3 id="2-长方形"><a href="#2-长方形" class="headerlink" title="2.长方形"></a>2.长方形</h3><p><img src="/前端CSS形状/长方形.png" alt=""></p><pre><code>#rectangle {            width: 200px;            height: 100px;            background: red;           }</code></pre><h3 id="3-圆形"><a href="#3-圆形" class="headerlink" title="3.圆形"></a>3.圆形</h3><p><img src="/前端CSS形状/圆形.png" alt=""></p><pre><code>#circle {         width: 100px;         height: 100px;         background: red;         border-radius: 50%;        }</code></pre><h3 id="4-椭圆形"><a href="#4-椭圆形" class="headerlink" title="4.椭圆形"></a>4.椭圆形</h3><p><img src="/前端CSS形状/椭圆.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于现在来讲，有很多的软件可以实现一些图标的样式，但是我们可以去学习那种思路和方法&lt;/p&gt;
&lt;h3 id=&quot;1-正方形&quot;&gt;&lt;a href=&quot;#1-正方形&quot; class=&quot;headerlink&quot; title=&quot;1.正方形&quot;&gt;&lt;/a&gt;1.正方形&lt;/h3&gt;&lt;p&gt;&lt;img src=
      
    
    </summary>
    
      <category term="前端" scheme="http://fireworksrain.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS样式" scheme="http://fireworksrain.com/tags/CSS%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
</feed>
